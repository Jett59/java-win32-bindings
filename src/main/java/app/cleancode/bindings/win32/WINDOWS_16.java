// Generated by jextract

package app.cleancode.bindings.win32;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import java.lang.foreign.*;
import static java.lang.foreign.ValueLayout.*;
 class WINDOWS_16 extends WINDOWS_15 {

    public static OfAddress PCERT_KEY_ATTRIBUTES_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_ID = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_KEY_USAGE_RESTRICTION_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_OTHER_NAME = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ALT_NAME_ENTRY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ALT_NAME_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_BASIC_CONSTRAINTS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_BASIC_CONSTRAINTS2_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_QUALIFIER_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICIES_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_QUALIFIER_USER_NOTICE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCPS_URLS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY95_QUALIFIER1 = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_MAPPING = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_MAPPINGS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_POLICY_CONSTRAINTS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CONTENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_SEQUENCE_OF_ANY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_AUTHORITY_KEY_ID2_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ACCESS_DESCRIPTION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_AUTHORITY_INFO_ACCESS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SUBJECT_INFO_ACCESS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_DIST_POINT_NAME = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_DIST_POINT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_DIST_POINTS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCROSS_CERT_DIST_POINTS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_PAIR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_ISSUING_DIST_POINT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_GENERAL_SUBTREE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_NAME_CONSTRAINTS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_DSS_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_DH_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ECC_SIGNATURE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_X942_DH_VALIDATION_PARAMS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_X942_DH_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_X942_OTHER_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ECC_CMS_SHARED_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_RC2_CBC_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_SMIME_CAPABILITY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_SMIME_CAPABILITIES = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_QC_STATEMENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_QC_STATEMENTS_EXT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_MASK_GEN_ALGORITHM = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_RSA_SSA_PSS_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PSOURCE_ALGORITHM = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_RSAES_OAEP_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_TAGGED_ATTRIBUTE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_TAGGED_CERT_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_TAGGED_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_TAGGED_CONTENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_TAGGED_OTHER_MSG = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_DATA_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_RESPONSE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_PEND_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_STATUS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_ADD_EXTENSIONS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMC_ADD_ATTRIBUTES_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_TEMPLATE_EXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_HASHED_URL = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_DETAILS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_REFERENCE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_IMAGE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_IMAGE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_AUDIO_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_AUDIO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_OTHER_LOGOTYPE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LOGOTYPE_EXT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_BIOMETRIC_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_BIOMETRIC_EXT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_SIGNATURE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_SIGNED_REQUEST_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_CERT_ID = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_REQUEST_ENTRY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_REQUEST_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_RESPONSE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_BASIC_SIGNED_RESPONSE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_BASIC_REVOKED_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_BASIC_RESPONSE_ENTRY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress POCSP_BASIC_RESPONSE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SUPPORTED_ALGORITHM_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_TPM_SPECIFICATION_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress HCRYPTOIDFUNCSET = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress HCRYPTOIDFUNCADDR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_OID_FUNC_ENTRY = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptInstallOIDFunctionAddress$MH() {
        return RuntimeHelper.requireNonNull(constants$574.CryptInstallOIDFunctionAddress$MH,"CryptInstallOIDFunctionAddress");
    }
    public static int CryptInstallOIDFunctionAddress ( Addressable hModule,  int dwEncodingType,  Addressable pszFuncName,  int cFuncEntry,  Addressable rgFuncEntry,  int dwFlags) {
        var mh$ = CryptInstallOIDFunctionAddress$MH();
        try {
            return (int)mh$.invokeExact(hModule, dwEncodingType, pszFuncName, cFuncEntry, rgFuncEntry, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptInitOIDFunctionSet$MH() {
        return RuntimeHelper.requireNonNull(constants$575.CryptInitOIDFunctionSet$MH,"CryptInitOIDFunctionSet");
    }
    public static MemoryAddress CryptInitOIDFunctionSet ( Addressable pszFuncName,  int dwFlags) {
        var mh$ = CryptInitOIDFunctionSet$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pszFuncName, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetOIDFunctionAddress$MH() {
        return RuntimeHelper.requireNonNull(constants$575.CryptGetOIDFunctionAddress$MH,"CryptGetOIDFunctionAddress");
    }
    public static int CryptGetOIDFunctionAddress ( Addressable hFuncSet,  int dwEncodingType,  Addressable pszOID,  int dwFlags,  Addressable ppvFuncAddr,  Addressable phFuncAddr) {
        var mh$ = CryptGetOIDFunctionAddress$MH();
        try {
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pszOID, dwFlags, ppvFuncAddr, phFuncAddr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetDefaultOIDDllList$MH() {
        return RuntimeHelper.requireNonNull(constants$575.CryptGetDefaultOIDDllList$MH,"CryptGetDefaultOIDDllList");
    }
    public static int CryptGetDefaultOIDDllList ( Addressable hFuncSet,  int dwEncodingType,  Addressable pwszDllList,  Addressable pcchDllList) {
        var mh$ = CryptGetDefaultOIDDllList$MH();
        try {
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pwszDllList, pcchDllList);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetDefaultOIDFunctionAddress$MH() {
        return RuntimeHelper.requireNonNull(constants$575.CryptGetDefaultOIDFunctionAddress$MH,"CryptGetDefaultOIDFunctionAddress");
    }
    public static int CryptGetDefaultOIDFunctionAddress ( Addressable hFuncSet,  int dwEncodingType,  Addressable pwszDll,  int dwFlags,  Addressable ppvFuncAddr,  Addressable phFuncAddr) {
        var mh$ = CryptGetDefaultOIDFunctionAddress$MH();
        try {
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pwszDll, dwFlags, ppvFuncAddr, phFuncAddr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptFreeOIDFunctionAddress$MH() {
        return RuntimeHelper.requireNonNull(constants$575.CryptFreeOIDFunctionAddress$MH,"CryptFreeOIDFunctionAddress");
    }
    public static int CryptFreeOIDFunctionAddress ( Addressable hFuncAddr,  int dwFlags) {
        var mh$ = CryptFreeOIDFunctionAddress$MH();
        try {
            return (int)mh$.invokeExact(hFuncAddr, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptRegisterOIDFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$575.CryptRegisterOIDFunction$MH,"CryptRegisterOIDFunction");
    }
    public static int CryptRegisterOIDFunction ( int dwEncodingType,  Addressable pszFuncName,  Addressable pszOID,  Addressable pwszDll,  Addressable pszOverrideFuncName) {
        var mh$ = CryptRegisterOIDFunction$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnregisterOIDFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$576.CryptUnregisterOIDFunction$MH,"CryptUnregisterOIDFunction");
    }
    public static int CryptUnregisterOIDFunction ( int dwEncodingType,  Addressable pszFuncName,  Addressable pszOID) {
        var mh$ = CryptUnregisterOIDFunction$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptRegisterDefaultOIDFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$576.CryptRegisterDefaultOIDFunction$MH,"CryptRegisterDefaultOIDFunction");
    }
    public static int CryptRegisterDefaultOIDFunction ( int dwEncodingType,  Addressable pszFuncName,  int dwIndex,  Addressable pwszDll) {
        var mh$ = CryptRegisterDefaultOIDFunction$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, dwIndex, pwszDll);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnregisterDefaultOIDFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$576.CryptUnregisterDefaultOIDFunction$MH,"CryptUnregisterDefaultOIDFunction");
    }
    public static int CryptUnregisterDefaultOIDFunction ( int dwEncodingType,  Addressable pszFuncName,  Addressable pwszDll) {
        var mh$ = CryptUnregisterDefaultOIDFunction$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pwszDll);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetOIDFunctionValue$MH() {
        return RuntimeHelper.requireNonNull(constants$576.CryptSetOIDFunctionValue$MH,"CryptSetOIDFunctionValue");
    }
    public static int CryptSetOIDFunctionValue ( int dwEncodingType,  Addressable pszFuncName,  Addressable pszOID,  Addressable pwszValueName,  int dwValueType,  Addressable pbValueData,  int cbValueData) {
        var mh$ = CryptSetOIDFunctionValue$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszValueName, dwValueType, pbValueData, cbValueData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetOIDFunctionValue$MH() {
        return RuntimeHelper.requireNonNull(constants$576.CryptGetOIDFunctionValue$MH,"CryptGetOIDFunctionValue");
    }
    public static int CryptGetOIDFunctionValue ( int dwEncodingType,  Addressable pszFuncName,  Addressable pszOID,  Addressable pwszValueName,  Addressable pdwValueType,  Addressable pbValueData,  Addressable pcbValueData) {
        var mh$ = CryptGetOIDFunctionValue$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszValueName, pdwValueType, pbValueData, pcbValueData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEnumOIDFunction$MH() {
        return RuntimeHelper.requireNonNull(constants$577.CryptEnumOIDFunction$MH,"CryptEnumOIDFunction");
    }
    public static int CryptEnumOIDFunction ( int dwEncodingType,  Addressable pszFuncName,  Addressable pszOID,  int dwFlags,  Addressable pvArg,  Addressable pfnEnumOIDFunc) {
        var mh$ = CryptEnumOIDFunction$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, dwFlags, pvArg, pfnEnumOIDFunc);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_OID_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCRYPT_OID_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptFindOIDInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$577.CryptFindOIDInfo$MH,"CryptFindOIDInfo");
    }
    public static MemoryAddress CryptFindOIDInfo ( int dwKeyType,  Addressable pvKey,  int dwGroupId) {
        var mh$ = CryptFindOIDInfo$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwKeyType, pvKey, dwGroupId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptRegisterOIDInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$577.CryptRegisterOIDInfo$MH,"CryptRegisterOIDInfo");
    }
    public static int CryptRegisterOIDInfo ( Addressable pInfo,  int dwFlags) {
        var mh$ = CryptRegisterOIDInfo$MH();
        try {
            return (int)mh$.invokeExact(pInfo, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnregisterOIDInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$577.CryptUnregisterOIDInfo$MH,"CryptUnregisterOIDInfo");
    }
    public static int CryptUnregisterOIDInfo ( Addressable pInfo) {
        var mh$ = CryptUnregisterOIDInfo$MH();
        try {
            return (int)mh$.invokeExact(pInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEnumOIDInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$578.CryptEnumOIDInfo$MH,"CryptEnumOIDInfo");
    }
    public static int CryptEnumOIDInfo ( int dwGroupId,  int dwFlags,  Addressable pvArg,  Addressable pfnEnumOIDInfo) {
        var mh$ = CryptEnumOIDInfo$MH();
        try {
            return (int)mh$.invokeExact(dwGroupId, dwFlags, pvArg, pfnEnumOIDInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptFindLocalizedName$MH() {
        return RuntimeHelper.requireNonNull(constants$578.CryptFindLocalizedName$MH,"CryptFindLocalizedName");
    }
    public static MemoryAddress CryptFindLocalizedName ( Addressable pwszCryptName) {
        var mh$ = CryptFindLocalizedName$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pwszCryptName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_STRONG_SIGN_SERIALIZED_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_STRONG_SIGN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_STRONG_SIGN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress HCRYPTMSG = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ISSUER_SERIAL_NUMBER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_ID = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_SIGNER_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_SIGNED_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_RECIPIENT_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_ENVELOPED_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_RC2_AUX_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_SP3_COMPATIBLE_AUX_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_RC4_AUX_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_HASHED_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_ENCRYPTED_ENCODE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_STREAM_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptMsgOpenToEncode$MH() {
        return RuntimeHelper.requireNonNull(constants$578.CryptMsgOpenToEncode$MH,"CryptMsgOpenToEncode");
    }
    public static MemoryAddress CryptMsgOpenToEncode ( int dwMsgEncodingType,  int dwFlags,  int dwMsgType,  Addressable pvMsgEncodeInfo,  Addressable pszInnerContentObjID,  Addressable pStreamInfo) {
        var mh$ = CryptMsgOpenToEncode$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgCalculateEncodedLength$MH() {
        return RuntimeHelper.requireNonNull(constants$579.CryptMsgCalculateEncodedLength$MH,"CryptMsgCalculateEncodedLength");
    }
    public static int CryptMsgCalculateEncodedLength ( int dwMsgEncodingType,  int dwFlags,  int dwMsgType,  Addressable pvMsgEncodeInfo,  Addressable pszInnerContentObjID,  int cbData) {
        var mh$ = CryptMsgCalculateEncodedLength$MH();
        try {
            return (int)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, cbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgOpenToDecode$MH() {
        return RuntimeHelper.requireNonNull(constants$579.CryptMsgOpenToDecode$MH,"CryptMsgOpenToDecode");
    }
    public static MemoryAddress CryptMsgOpenToDecode ( int dwMsgEncodingType,  int dwFlags,  int dwMsgType,  long hCryptProv,  Addressable pRecipientInfo,  Addressable pStreamInfo) {
        var mh$ = CryptMsgOpenToDecode$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgDuplicate$MH() {
        return RuntimeHelper.requireNonNull(constants$579.CryptMsgDuplicate$MH,"CryptMsgDuplicate");
    }
    public static MemoryAddress CryptMsgDuplicate ( Addressable hCryptMsg) {
        var mh$ = CryptMsgDuplicate$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCryptMsg);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgClose$MH() {
        return RuntimeHelper.requireNonNull(constants$579.CryptMsgClose$MH,"CryptMsgClose");
    }
    public static int CryptMsgClose ( Addressable hCryptMsg) {
        var mh$ = CryptMsgClose$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgUpdate$MH() {
        return RuntimeHelper.requireNonNull(constants$579.CryptMsgUpdate$MH,"CryptMsgUpdate");
    }
    public static int CryptMsgUpdate ( Addressable hCryptMsg,  Addressable pbData,  int cbData,  int fFinal) {
        var mh$ = CryptMsgUpdate$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg, pbData, cbData, fFinal);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgGetParam$MH() {
        return RuntimeHelper.requireNonNull(constants$579.CryptMsgGetParam$MH,"CryptMsgGetParam");
    }
    public static int CryptMsgGetParam ( Addressable hCryptMsg,  int dwParamType,  int dwIndex,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CryptMsgGetParam$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg, dwParamType, dwIndex, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCMSG_SIGNER_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CMS_SIGNER_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_ATTR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_TRANS_RECIPIENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_AGREE_RECIPIENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_MAIL_LIST_RECIPIENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CMS_RECIPIENT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptMsgControl$MH() {
        return RuntimeHelper.requireNonNull(constants$580.CryptMsgControl$MH,"CryptMsgControl");
    }
    public static int CryptMsgControl ( Addressable hCryptMsg,  int dwFlags,  int dwCtrlType,  Addressable pvCtrlPara) {
        var mh$ = CryptMsgControl$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_DECRYPT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptMsgVerifyCountersignatureEncoded$MH() {
        return RuntimeHelper.requireNonNull(constants$580.CryptMsgVerifyCountersignatureEncoded$MH,"CryptMsgVerifyCountersignatureEncoded");
    }
    public static int CryptMsgVerifyCountersignatureEncoded ( long hCryptProv,  int dwEncodingType,  Addressable pbSignerInfo,  int cbSignerInfo,  Addressable pbSignerInfoCountersignature,  int cbSignerInfoCountersignature,  Addressable pciCountersigner) {
        var mh$ = CryptMsgVerifyCountersignatureEncoded$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, pciCountersigner);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgVerifyCountersignatureEncodedEx$MH() {
        return RuntimeHelper.requireNonNull(constants$580.CryptMsgVerifyCountersignatureEncodedEx$MH,"CryptMsgVerifyCountersignatureEncodedEx");
    }
    public static int CryptMsgVerifyCountersignatureEncodedEx ( long hCryptProv,  int dwEncodingType,  Addressable pbSignerInfo,  int cbSignerInfo,  Addressable pbSignerInfoCountersignature,  int cbSignerInfoCountersignature,  int dwSignerType,  Addressable pvSigner,  int dwFlags,  Addressable pvExtra) {
        var mh$ = CryptMsgVerifyCountersignatureEncodedEx$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, dwSignerType, pvSigner, dwFlags, pvExtra);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgCountersign$MH() {
        return RuntimeHelper.requireNonNull(constants$580.CryptMsgCountersign$MH,"CryptMsgCountersign");
    }
    public static int CryptMsgCountersign ( Addressable hCryptMsg,  int dwIndex,  int cCountersigners,  Addressable rgCountersigners) {
        var mh$ = CryptMsgCountersign$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg, dwIndex, cCountersigners, rgCountersigners);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgCountersignEncoded$MH() {
        return RuntimeHelper.requireNonNull(constants$580.CryptMsgCountersignEncoded$MH,"CryptMsgCountersignEncoded");
    }
    public static int CryptMsgCountersignEncoded ( int dwEncodingType,  Addressable pbSignerInfo,  int cbSignerInfo,  int cCountersigners,  Addressable rgCountersigners,  Addressable pbCountersignature,  Addressable pcbCountersignature) {
        var mh$ = CryptMsgCountersignEncoded$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, pbSignerInfo, cbSignerInfo, cCountersigners, rgCountersigners, pbCountersignature, pcbCountersignature);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCMSG_CONTENT_ENCRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_TRANS_ENCRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_KEY_AGREE_ENCRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_MAIL_LIST_ENCRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCMSG_CNG_CONTENT_DECRYPT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress HCERTSTORE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRL_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCRL_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCTL_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static int KeyTypeOther() {
        return (int)0L;
    }
    public static int KeyTypeVirtualSmartCard() {
        return (int)1L;
    }
    public static int KeyTypePhysicalSmartCard() {
        return (int)2L;
    }
    public static int KeyTypePassport() {
        return (int)3L;
    }
    public static int KeyTypePassportRemote() {
        return (int)4L;
    }
    public static int KeyTypePassportSmartCard() {
        return (int)5L;
    }
    public static int KeyTypeHardware() {
        return (int)6L;
    }
    public static int KeyTypeSoftware() {
        return (int)7L;
    }
    public static int KeyTypeSelfSigned() {
        return (int)8L;
    }
    public static OfAddress PCRYPT_KEY_PROV_PARAM = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_KEY_PROV_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_KEY_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PROOT_INFO_LUID = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_SMART_CARD_ROOT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SYSTEM_STORE_RELOCATE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REGISTRY_STORE_CLIENT_GPT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REGISTRY_STORE_ROAMING_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_LDAP_STORE_OPENED_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertOpenStore$MH() {
        return RuntimeHelper.requireNonNull(constants$585.CertOpenStore$MH,"CertOpenStore");
    }
    public static MemoryAddress CertOpenStore ( Addressable lpszStoreProvider,  int dwEncodingType,  long hCryptProv,  int dwFlags,  Addressable pvPara) {
        var mh$ = CertOpenStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress HCERTSTOREPROV = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_STORE_PROV_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_STORE_PROV_FIND_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_STORE_PROV_FIND_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertDuplicateStore$MH() {
        return RuntimeHelper.requireNonNull(constants$594.CertDuplicateStore$MH,"CertDuplicateStore");
    }
    public static MemoryAddress CertDuplicateStore ( Addressable hCertStore) {
        var mh$ = CertDuplicateStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSaveStore$MH() {
        return RuntimeHelper.requireNonNull(constants$594.CertSaveStore$MH,"CertSaveStore");
    }
    public static int CertSaveStore ( Addressable hCertStore,  int dwEncodingType,  int dwSaveAs,  int dwSaveTo,  Addressable pvSaveToPara,  int dwFlags) {
        var mh$ = CertSaveStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwEncodingType, dwSaveAs, dwSaveTo, pvSaveToPara, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCloseStore$MH() {
        return RuntimeHelper.requireNonNull(constants$594.CertCloseStore$MH,"CertCloseStore");
    }
    public static int CertCloseStore ( Addressable hCertStore,  int dwFlags) {
        var mh$ = CertCloseStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetSubjectCertificateFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$594.CertGetSubjectCertificateFromStore$MH,"CertGetSubjectCertificateFromStore");
    }
    public static MemoryAddress CertGetSubjectCertificateFromStore ( Addressable hCertStore,  int dwCertEncodingType,  Addressable pCertId) {
        var mh$ = CertGetSubjectCertificateFromStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, dwCertEncodingType, pCertId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCertificatesInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$594.CertEnumCertificatesInStore$MH,"CertEnumCertificatesInStore");
    }
    public static MemoryAddress CertEnumCertificatesInStore ( Addressable hCertStore,  Addressable pPrevCertContext) {
        var mh$ = CertEnumCertificatesInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, pPrevCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindCertificateInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$594.CertFindCertificateInStore$MH,"CertFindCertificateInStore");
    }
    public static MemoryAddress CertFindCertificateInStore ( Addressable hCertStore,  int dwCertEncodingType,  int dwFindFlags,  int dwFindType,  Addressable pvFindPara,  Addressable pPrevCertContext) {
        var mh$ = CertFindCertificateInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetIssuerCertificateFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$595.CertGetIssuerCertificateFromStore$MH,"CertGetIssuerCertificateFromStore");
    }
    public static MemoryAddress CertGetIssuerCertificateFromStore ( Addressable hCertStore,  Addressable pSubjectContext,  Addressable pPrevIssuerContext,  Addressable pdwFlags) {
        var mh$ = CertGetIssuerCertificateFromStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertVerifySubjectCertificateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$595.CertVerifySubjectCertificateContext$MH,"CertVerifySubjectCertificateContext");
    }
    public static int CertVerifySubjectCertificateContext ( Addressable pSubject,  Addressable pIssuer,  Addressable pdwFlags) {
        var mh$ = CertVerifySubjectCertificateContext$MH();
        try {
            return (int)mh$.invokeExact(pSubject, pIssuer, pdwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDuplicateCertificateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$595.CertDuplicateCertificateContext$MH,"CertDuplicateCertificateContext");
    }
    public static MemoryAddress CertDuplicateCertificateContext ( Addressable pCertContext) {
        var mh$ = CertDuplicateCertificateContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCreateCertificateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$595.CertCreateCertificateContext$MH,"CertCreateCertificateContext");
    }
    public static MemoryAddress CertCreateCertificateContext ( int dwCertEncodingType,  Addressable pbCertEncoded,  int cbCertEncoded) {
        var mh$ = CertCreateCertificateContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwCertEncodingType, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCertificateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$595.CertFreeCertificateContext$MH,"CertFreeCertificateContext");
    }
    public static int CertFreeCertificateContext ( Addressable pCertContext) {
        var mh$ = CertFreeCertificateContext$MH();
        try {
            return (int)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetCertificateContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$595.CertSetCertificateContextProperty$MH,"CertSetCertificateContextProperty");
    }
    public static int CertSetCertificateContextProperty ( Addressable pCertContext,  int dwPropId,  int dwFlags,  Addressable pvData) {
        var mh$ = CertSetCertificateContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetCertificateContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$596.CertGetCertificateContextProperty$MH,"CertGetCertificateContextProperty");
    }
    public static int CertGetCertificateContextProperty ( Addressable pCertContext,  int dwPropId,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CertGetCertificateContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCertificateContextProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$596.CertEnumCertificateContextProperties$MH,"CertEnumCertificateContextProperties");
    }
    public static int CertEnumCertificateContextProperties ( Addressable pCertContext,  int dwPropId) {
        var mh$ = CertEnumCertificateContextProperties$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwPropId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCreateCTLEntryFromCertificateContextProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$596.CertCreateCTLEntryFromCertificateContextProperties$MH,"CertCreateCTLEntryFromCertificateContextProperties");
    }
    public static int CertCreateCTLEntryFromCertificateContextProperties ( Addressable pCertContext,  int cOptAttr,  Addressable rgOptAttr,  int dwFlags,  Addressable pvReserved,  Addressable pCtlEntry,  Addressable pcbCtlEntry) {
        var mh$ = CertCreateCTLEntryFromCertificateContextProperties$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, cOptAttr, rgOptAttr, dwFlags, pvReserved, pCtlEntry, pcbCtlEntry);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetCertificateContextPropertiesFromCTLEntry$MH() {
        return RuntimeHelper.requireNonNull(constants$596.CertSetCertificateContextPropertiesFromCTLEntry$MH,"CertSetCertificateContextPropertiesFromCTLEntry");
    }
    public static int CertSetCertificateContextPropertiesFromCTLEntry ( Addressable pCertContext,  Addressable pCtlEntry,  int dwFlags) {
        var mh$ = CertSetCertificateContextPropertiesFromCTLEntry$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, pCtlEntry, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetCRLFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$596.CertGetCRLFromStore$MH,"CertGetCRLFromStore");
    }
    public static MemoryAddress CertGetCRLFromStore ( Addressable hCertStore,  Addressable pIssuerContext,  Addressable pPrevCrlContext,  Addressable pdwFlags) {
        var mh$ = CertGetCRLFromStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, pIssuerContext, pPrevCrlContext, pdwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCRLsInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$596.CertEnumCRLsInStore$MH,"CertEnumCRLsInStore");
    }
    public static MemoryAddress CertEnumCRLsInStore ( Addressable hCertStore,  Addressable pPrevCrlContext) {
        var mh$ = CertEnumCRLsInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, pPrevCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindCRLInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$597.CertFindCRLInStore$MH,"CertFindCRLInStore");
    }
    public static MemoryAddress CertFindCRLInStore ( Addressable hCertStore,  int dwCertEncodingType,  int dwFindFlags,  int dwFindType,  Addressable pvFindPara,  Addressable pPrevCrlContext) {
        var mh$ = CertFindCRLInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRL_FIND_ISSUED_FOR_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertDuplicateCRLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$597.CertDuplicateCRLContext$MH,"CertDuplicateCRLContext");
    }
    public static MemoryAddress CertDuplicateCRLContext ( Addressable pCrlContext) {
        var mh$ = CertDuplicateCRLContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCreateCRLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$597.CertCreateCRLContext$MH,"CertCreateCRLContext");
    }
    public static MemoryAddress CertCreateCRLContext ( int dwCertEncodingType,  Addressable pbCrlEncoded,  int cbCrlEncoded) {
        var mh$ = CertCreateCRLContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCRLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$597.CertFreeCRLContext$MH,"CertFreeCRLContext");
    }
    public static int CertFreeCRLContext ( Addressable pCrlContext) {
        var mh$ = CertFreeCRLContext$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetCRLContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$597.CertSetCRLContextProperty$MH,"CertSetCRLContextProperty");
    }
    public static int CertSetCRLContextProperty ( Addressable pCrlContext,  int dwPropId,  int dwFlags,  Addressable pvData) {
        var mh$ = CertSetCRLContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetCRLContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$597.CertGetCRLContextProperty$MH,"CertGetCRLContextProperty");
    }
    public static int CertGetCRLContextProperty ( Addressable pCrlContext,  int dwPropId,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CertGetCRLContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCRLContextProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$598.CertEnumCRLContextProperties$MH,"CertEnumCRLContextProperties");
    }
    public static int CertEnumCRLContextProperties ( Addressable pCrlContext,  int dwPropId) {
        var mh$ = CertEnumCRLContextProperties$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext, dwPropId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindCertificateInCRL$MH() {
        return RuntimeHelper.requireNonNull(constants$598.CertFindCertificateInCRL$MH,"CertFindCertificateInCRL");
    }
    public static int CertFindCertificateInCRL ( Addressable pCert,  Addressable pCrlContext,  int dwFlags,  Addressable pvReserved,  Addressable ppCrlEntry) {
        var mh$ = CertFindCertificateInCRL$MH();
        try {
            return (int)mh$.invokeExact(pCert, pCrlContext, dwFlags, pvReserved, ppCrlEntry);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertIsValidCRLForCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$598.CertIsValidCRLForCertificate$MH,"CertIsValidCRLForCertificate");
    }
    public static int CertIsValidCRLForCertificate ( Addressable pCert,  Addressable pCrl,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CertIsValidCRLForCertificate$MH();
        try {
            return (int)mh$.invokeExact(pCert, pCrl, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddEncodedCertificateToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$598.CertAddEncodedCertificateToStore$MH,"CertAddEncodedCertificateToStore");
    }
    public static int CertAddEncodedCertificateToStore ( Addressable hCertStore,  int dwCertEncodingType,  Addressable pbCertEncoded,  int cbCertEncoded,  int dwAddDisposition,  Addressable ppCertContext) {
        var mh$ = CertAddEncodedCertificateToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCertificateContextToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$598.CertAddCertificateContextToStore$MH,"CertAddCertificateContextToStore");
    }
    public static int CertAddCertificateContextToStore ( Addressable hCertStore,  Addressable pCertContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCertificateContextToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddSerializedElementToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$598.CertAddSerializedElementToStore$MH,"CertAddSerializedElementToStore");
    }
    public static int CertAddSerializedElementToStore ( Addressable hCertStore,  Addressable pbElement,  int cbElement,  int dwAddDisposition,  int dwFlags,  int dwContextTypeFlags,  Addressable pdwContextType,  Addressable ppvContext) {
        var mh$ = CertAddSerializedElementToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pbElement, cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, pdwContextType, ppvContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDeleteCertificateFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$599.CertDeleteCertificateFromStore$MH,"CertDeleteCertificateFromStore");
    }
    public static int CertDeleteCertificateFromStore ( Addressable pCertContext) {
        var mh$ = CertDeleteCertificateFromStore$MH();
        try {
            return (int)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddEncodedCRLToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$599.CertAddEncodedCRLToStore$MH,"CertAddEncodedCRLToStore");
    }
    public static int CertAddEncodedCRLToStore ( Addressable hCertStore,  int dwCertEncodingType,  Addressable pbCrlEncoded,  int cbCrlEncoded,  int dwAddDisposition,  Addressable ppCrlContext) {
        var mh$ = CertAddEncodedCRLToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCRLContextToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$599.CertAddCRLContextToStore$MH,"CertAddCRLContextToStore");
    }
    public static int CertAddCRLContextToStore ( Addressable hCertStore,  Addressable pCrlContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCRLContextToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDeleteCRLFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$599.CertDeleteCRLFromStore$MH,"CertDeleteCRLFromStore");
    }
    public static int CertDeleteCRLFromStore ( Addressable pCrlContext) {
        var mh$ = CertDeleteCRLFromStore$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSerializeCertificateStoreElement$MH() {
        return RuntimeHelper.requireNonNull(constants$599.CertSerializeCertificateStoreElement$MH,"CertSerializeCertificateStoreElement");
    }
    public static int CertSerializeCertificateStoreElement ( Addressable pCertContext,  int dwFlags,  Addressable pbElement,  Addressable pcbElement) {
        var mh$ = CertSerializeCertificateStoreElement$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSerializeCRLStoreElement$MH() {
        return RuntimeHelper.requireNonNull(constants$599.CertSerializeCRLStoreElement$MH,"CertSerializeCRLStoreElement");
    }
    public static int CertSerializeCRLStoreElement ( Addressable pCrlContext,  int dwFlags,  Addressable pbElement,  Addressable pcbElement) {
        var mh$ = CertSerializeCRLStoreElement$MH();
        try {
            return (int)mh$.invokeExact(pCrlContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDuplicateCTLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$600.CertDuplicateCTLContext$MH,"CertDuplicateCTLContext");
    }
    public static MemoryAddress CertDuplicateCTLContext ( Addressable pCtlContext) {
        var mh$ = CertDuplicateCTLContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCreateCTLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$600.CertCreateCTLContext$MH,"CertCreateCTLContext");
    }
    public static MemoryAddress CertCreateCTLContext ( int dwMsgAndCertEncodingType,  Addressable pbCtlEncoded,  int cbCtlEncoded) {
        var mh$ = CertCreateCTLContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCTLContext$MH() {
        return RuntimeHelper.requireNonNull(constants$600.CertFreeCTLContext$MH,"CertFreeCTLContext");
    }
    public static int CertFreeCTLContext ( Addressable pCtlContext) {
        var mh$ = CertFreeCTLContext$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetCTLContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$600.CertSetCTLContextProperty$MH,"CertSetCTLContextProperty");
    }
    public static int CertSetCTLContextProperty ( Addressable pCtlContext,  int dwPropId,  int dwFlags,  Addressable pvData) {
        var mh$ = CertSetCTLContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetCTLContextProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$600.CertGetCTLContextProperty$MH,"CertGetCTLContextProperty");
    }
    public static int CertGetCTLContextProperty ( Addressable pCtlContext,  int dwPropId,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CertGetCTLContextProperty$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCTLContextProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$600.CertEnumCTLContextProperties$MH,"CertEnumCTLContextProperties");
    }
    public static int CertEnumCTLContextProperties ( Addressable pCtlContext,  int dwPropId) {
        var mh$ = CertEnumCTLContextProperties$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext, dwPropId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumCTLsInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$601.CertEnumCTLsInStore$MH,"CertEnumCTLsInStore");
    }
    public static MemoryAddress CertEnumCTLsInStore ( Addressable hCertStore,  Addressable pPrevCtlContext) {
        var mh$ = CertEnumCTLsInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, pPrevCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindSubjectInCTL$MH() {
        return RuntimeHelper.requireNonNull(constants$601.CertFindSubjectInCTL$MH,"CertFindSubjectInCTL");
    }
    public static MemoryAddress CertFindSubjectInCTL ( int dwEncodingType,  int dwSubjectType,  Addressable pvSubject,  Addressable pCtlContext,  int dwFlags) {
        var mh$ = CertFindSubjectInCTL$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCTL_ANY_SUBJECT_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertFindCTLInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$601.CertFindCTLInStore$MH,"CertFindCTLInStore");
    }
    public static MemoryAddress CertFindCTLInStore ( Addressable hCertStore,  int dwMsgAndCertEncodingType,  int dwFindFlags,  int dwFindType,  Addressable pvFindPara,  Addressable pPrevCtlContext) {
        var mh$ = CertFindCTLInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, dwMsgAndCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCTL_FIND_USAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_FIND_SUBJECT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertAddEncodedCTLToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$601.CertAddEncodedCTLToStore$MH,"CertAddEncodedCTLToStore");
    }
    public static int CertAddEncodedCTLToStore ( Addressable hCertStore,  int dwMsgAndCertEncodingType,  Addressable pbCtlEncoded,  int cbCtlEncoded,  int dwAddDisposition,  Addressable ppCtlContext) {
        var mh$ = CertAddEncodedCTLToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded, dwAddDisposition, ppCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCTLContextToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$601.CertAddCTLContextToStore$MH,"CertAddCTLContextToStore");
    }
    public static int CertAddCTLContextToStore ( Addressable hCertStore,  Addressable pCtlContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCTLContextToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSerializeCTLStoreElement$MH() {
        return RuntimeHelper.requireNonNull(constants$601.CertSerializeCTLStoreElement$MH,"CertSerializeCTLStoreElement");
    }
    public static int CertSerializeCTLStoreElement ( Addressable pCtlContext,  int dwFlags,  Addressable pbElement,  Addressable pcbElement) {
        var mh$ = CertSerializeCTLStoreElement$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDeleteCTLFromStore$MH() {
        return RuntimeHelper.requireNonNull(constants$602.CertDeleteCTLFromStore$MH,"CertDeleteCTLFromStore");
    }
    public static int CertDeleteCTLFromStore ( Addressable pCtlContext) {
        var mh$ = CertDeleteCTLFromStore$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCertificateLinkToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$602.CertAddCertificateLinkToStore$MH,"CertAddCertificateLinkToStore");
    }
    public static int CertAddCertificateLinkToStore ( Addressable hCertStore,  Addressable pCertContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCertificateLinkToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCRLLinkToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$602.CertAddCRLLinkToStore$MH,"CertAddCRLLinkToStore");
    }
    public static int CertAddCRLLinkToStore ( Addressable hCertStore,  Addressable pCrlContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCRLLinkToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddCTLLinkToStore$MH() {
        return RuntimeHelper.requireNonNull(constants$602.CertAddCTLLinkToStore$MH,"CertAddCTLLinkToStore");
    }
    public static int CertAddCTLLinkToStore ( Addressable hCertStore,  Addressable pCtlContext,  int dwAddDisposition,  Addressable ppStoreContext) {
        var mh$ = CertAddCTLLinkToStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddStoreToCollection$MH() {
        return RuntimeHelper.requireNonNull(constants$602.CertAddStoreToCollection$MH,"CertAddStoreToCollection");
    }
    public static int CertAddStoreToCollection ( Addressable hCollectionStore,  Addressable hSiblingStore,  int dwUpdateFlags,  int dwPriority) {
        var mh$ = CertAddStoreToCollection$MH();
        try {
            return (int)mh$.invokeExact(hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRemoveStoreFromCollection$MH() {
        return RuntimeHelper.requireNonNull(constants$602.CertRemoveStoreFromCollection$MH,"CertRemoveStoreFromCollection");
    }
    public static void CertRemoveStoreFromCollection ( Addressable hCollectionStore,  Addressable hSiblingStore) {
        var mh$ = CertRemoveStoreFromCollection$MH();
        try {
            mh$.invokeExact(hCollectionStore, hSiblingStore);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertControlStore$MH() {
        return RuntimeHelper.requireNonNull(constants$603.CertControlStore$MH,"CertControlStore");
    }
    public static int CertControlStore ( Addressable hCertStore,  int dwFlags,  int dwCtrlType,  Addressable pvCtrlPara) {
        var mh$ = CertControlStore$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwFlags, dwCtrlType, pvCtrlPara);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetStoreProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$603.CertSetStoreProperty$MH,"CertSetStoreProperty");
    }
    public static int CertSetStoreProperty ( Addressable hCertStore,  int dwPropId,  int dwFlags,  Addressable pvData) {
        var mh$ = CertSetStoreProperty$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetStoreProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$603.CertGetStoreProperty$MH,"CertGetStoreProperty");
    }
    public static int CertGetStoreProperty ( Addressable hCertStore,  int dwPropId,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CertGetStoreProperty$MH();
        try {
            return (int)mh$.invokeExact(hCertStore, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_CREATE_CONTEXT_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertCreateContext$MH() {
        return RuntimeHelper.requireNonNull(constants$603.CertCreateContext$MH,"CertCreateContext");
    }
    public static MemoryAddress CertCreateContext ( int dwContextType,  int dwEncodingType,  Addressable pbEncoded,  int cbEncoded,  int dwFlags,  Addressable pCreatePara) {
        var mh$ = CertCreateContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwContextType, dwEncodingType, pbEncoded, cbEncoded, dwFlags, pCreatePara);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_SYSTEM_STORE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_PHYSICAL_STORE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertRegisterSystemStore$MH() {
        return RuntimeHelper.requireNonNull(constants$604.CertRegisterSystemStore$MH,"CertRegisterSystemStore");
    }
    public static int CertRegisterSystemStore ( Addressable pvSystemStore,  int dwFlags,  Addressable pStoreInfo,  Addressable pvReserved) {
        var mh$ = CertRegisterSystemStore$MH();
        try {
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pStoreInfo, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRegisterPhysicalStore$MH() {
        return RuntimeHelper.requireNonNull(constants$604.CertRegisterPhysicalStore$MH,"CertRegisterPhysicalStore");
    }
    public static int CertRegisterPhysicalStore ( Addressable pvSystemStore,  int dwFlags,  Addressable pwszStoreName,  Addressable pStoreInfo,  Addressable pvReserved) {
        var mh$ = CertRegisterPhysicalStore$MH();
        try {
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pwszStoreName, pStoreInfo, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertUnregisterSystemStore$MH() {
        return RuntimeHelper.requireNonNull(constants$604.CertUnregisterSystemStore$MH,"CertUnregisterSystemStore");
    }
    public static int CertUnregisterSystemStore ( Addressable pvSystemStore,  int dwFlags) {
        var mh$ = CertUnregisterSystemStore$MH();
        try {
            return (int)mh$.invokeExact(pvSystemStore, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertUnregisterPhysicalStore$MH() {
        return RuntimeHelper.requireNonNull(constants$604.CertUnregisterPhysicalStore$MH,"CertUnregisterPhysicalStore");
    }
    public static int CertUnregisterPhysicalStore ( Addressable pvSystemStore,  int dwFlags,  Addressable pwszStoreName) {
        var mh$ = CertUnregisterPhysicalStore$MH();
        try {
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pwszStoreName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumSystemStoreLocation$MH() {
        return RuntimeHelper.requireNonNull(constants$605.CertEnumSystemStoreLocation$MH,"CertEnumSystemStoreLocation");
    }
    public static int CertEnumSystemStoreLocation ( int dwFlags,  Addressable pvArg,  Addressable pfnEnum) {
        var mh$ = CertEnumSystemStoreLocation$MH();
        try {
            return (int)mh$.invokeExact(dwFlags, pvArg, pfnEnum);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumSystemStore$MH() {
        return RuntimeHelper.requireNonNull(constants$605.CertEnumSystemStore$MH,"CertEnumSystemStore");
    }
    public static int CertEnumSystemStore ( int dwFlags,  Addressable pvSystemStoreLocationPara,  Addressable pvArg,  Addressable pfnEnum) {
        var mh$ = CertEnumSystemStore$MH();
        try {
            return (int)mh$.invokeExact(dwFlags, pvSystemStoreLocationPara, pvArg, pfnEnum);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumPhysicalStore$MH() {
        return RuntimeHelper.requireNonNull(constants$606.CertEnumPhysicalStore$MH,"CertEnumPhysicalStore");
    }
    public static int CertEnumPhysicalStore ( Addressable pvSystemStore,  int dwFlags,  Addressable pvArg,  Addressable pfnEnum) {
        var mh$ = CertEnumPhysicalStore$MH();
        try {
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pvArg, pfnEnum);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetEnhancedKeyUsage$MH() {
        return RuntimeHelper.requireNonNull(constants$606.CertGetEnhancedKeyUsage$MH,"CertGetEnhancedKeyUsage");
    }
    public static int CertGetEnhancedKeyUsage ( Addressable pCertContext,  int dwFlags,  Addressable pUsage,  Addressable pcbUsage) {
        var mh$ = CertGetEnhancedKeyUsage$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwFlags, pUsage, pcbUsage);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertSetEnhancedKeyUsage$MH() {
        return RuntimeHelper.requireNonNull(constants$606.CertSetEnhancedKeyUsage$MH,"CertSetEnhancedKeyUsage");
    }
    public static int CertSetEnhancedKeyUsage ( Addressable pCertContext,  Addressable pUsage) {
        var mh$ = CertSetEnhancedKeyUsage$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, pUsage);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddEnhancedKeyUsageIdentifier$MH() {
        return RuntimeHelper.requireNonNull(constants$606.CertAddEnhancedKeyUsageIdentifier$MH,"CertAddEnhancedKeyUsageIdentifier");
    }
    public static int CertAddEnhancedKeyUsageIdentifier ( Addressable pCertContext,  Addressable pszUsageIdentifier) {
        var mh$ = CertAddEnhancedKeyUsageIdentifier$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, pszUsageIdentifier);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRemoveEnhancedKeyUsageIdentifier$MH() {
        return RuntimeHelper.requireNonNull(constants$606.CertRemoveEnhancedKeyUsageIdentifier$MH,"CertRemoveEnhancedKeyUsageIdentifier");
    }
    public static int CertRemoveEnhancedKeyUsageIdentifier ( Addressable pCertContext,  Addressable pszUsageIdentifier) {
        var mh$ = CertRemoveEnhancedKeyUsageIdentifier$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, pszUsageIdentifier);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetValidUsages$MH() {
        return RuntimeHelper.requireNonNull(constants$606.CertGetValidUsages$MH,"CertGetValidUsages");
    }
    public static int CertGetValidUsages ( int cCerts,  Addressable rghCerts,  Addressable cNumOIDs,  Addressable rghOIDs,  Addressable pcbOIDs) {
        var mh$ = CertGetValidUsages$MH();
        try {
            return (int)mh$.invokeExact(cCerts, rghCerts, cNumOIDs, rghOIDs, pcbOIDs);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgGetAndVerifySigner$MH() {
        return RuntimeHelper.requireNonNull(constants$607.CryptMsgGetAndVerifySigner$MH,"CryptMsgGetAndVerifySigner");
    }
    public static int CryptMsgGetAndVerifySigner ( Addressable hCryptMsg,  int cSignerStore,  Addressable rghSignerStore,  int dwFlags,  Addressable ppSigner,  Addressable pdwSignerIndex) {
        var mh$ = CryptMsgGetAndVerifySigner$MH();
        try {
            return (int)mh$.invokeExact(hCryptMsg, cSignerStore, rghSignerStore, dwFlags, ppSigner, pdwSignerIndex);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgSignCTL$MH() {
        return RuntimeHelper.requireNonNull(constants$607.CryptMsgSignCTL$MH,"CryptMsgSignCTL");
    }
    public static int CryptMsgSignCTL ( int dwMsgEncodingType,  Addressable pbCtlContent,  int cbCtlContent,  Addressable pSignInfo,  int dwFlags,  Addressable pbEncoded,  Addressable pcbEncoded) {
        var mh$ = CryptMsgSignCTL$MH();
        try {
            return (int)mh$.invokeExact(dwMsgEncodingType, pbCtlContent, cbCtlContent, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMsgEncodeAndSignCTL$MH() {
        return RuntimeHelper.requireNonNull(constants$607.CryptMsgEncodeAndSignCTL$MH,"CryptMsgEncodeAndSignCTL");
    }
    public static int CryptMsgEncodeAndSignCTL ( int dwMsgEncodingType,  Addressable pCtlInfo,  Addressable pSignInfo,  int dwFlags,  Addressable pbEncoded,  Addressable pcbEncoded) {
        var mh$ = CryptMsgEncodeAndSignCTL$MH();
        try {
            return (int)mh$.invokeExact(dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindSubjectInSortedCTL$MH() {
        return RuntimeHelper.requireNonNull(constants$607.CertFindSubjectInSortedCTL$MH,"CertFindSubjectInSortedCTL");
    }
    public static int CertFindSubjectInSortedCTL ( Addressable pSubjectIdentifier,  Addressable pCtlContext,  int dwFlags,  Addressable pvReserved,  Addressable pEncodedAttributes) {
        var mh$ = CertFindSubjectInSortedCTL$MH();
        try {
            return (int)mh$.invokeExact(pSubjectIdentifier, pCtlContext, dwFlags, pvReserved, pEncodedAttributes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertEnumSubjectInSortedCTL$MH() {
        return RuntimeHelper.requireNonNull(constants$607.CertEnumSubjectInSortedCTL$MH,"CertEnumSubjectInSortedCTL");
    }
    public static int CertEnumSubjectInSortedCTL ( Addressable pCtlContext,  Addressable ppvNextSubject,  Addressable pSubjectIdentifier,  Addressable pEncodedAttributes) {
        var mh$ = CertEnumSubjectInSortedCTL$MH();
        try {
            return (int)mh$.invokeExact(pCtlContext, ppvNextSubject, pSubjectIdentifier, pEncodedAttributes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCTL_VERIFY_USAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_VERIFY_USAGE_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertVerifyCTLUsage$MH() {
        return RuntimeHelper.requireNonNull(constants$607.CertVerifyCTLUsage$MH,"CertVerifyCTLUsage");
    }
    public static int CertVerifyCTLUsage ( int dwEncodingType,  int dwSubjectType,  Addressable pvSubject,  Addressable pSubjectUsage,  int dwFlags,  Addressable pVerifyUsagePara,  Addressable pVerifyUsageStatus) {
        var mh$ = CertVerifyCTLUsage$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags, pVerifyUsagePara, pVerifyUsageStatus);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_REVOCATION_CRL_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REVOCATION_CHAIN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REVOCATION_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REVOCATION_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertVerifyRevocation$MH() {
        return RuntimeHelper.requireNonNull(constants$608.CertVerifyRevocation$MH,"CertVerifyRevocation");
    }
    public static int CertVerifyRevocation ( int dwEncodingType,  int dwRevType,  int cContext,  Addressable rgpvContext,  int dwFlags,  Addressable pRevPara,  Addressable pRevStatus) {
        var mh$ = CertVerifyRevocation$MH();
        try {
            return (int)mh$.invokeExact(dwEncodingType, dwRevType, cContext, rgpvContext, dwFlags, pRevPara, pRevStatus);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCompareIntegerBlob$MH() {
        return RuntimeHelper.requireNonNull(constants$608.CertCompareIntegerBlob$MH,"CertCompareIntegerBlob");
    }
    public static int CertCompareIntegerBlob ( Addressable pInt1,  Addressable pInt2) {
        var mh$ = CertCompareIntegerBlob$MH();
        try {
            return (int)mh$.invokeExact(pInt1, pInt2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCompareCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$608.CertCompareCertificate$MH,"CertCompareCertificate");
    }
    public static int CertCompareCertificate ( int dwCertEncodingType,  Addressable pCertId1,  Addressable pCertId2) {
        var mh$ = CertCompareCertificate$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pCertId1, pCertId2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCompareCertificateName$MH() {
        return RuntimeHelper.requireNonNull(constants$608.CertCompareCertificateName$MH,"CertCompareCertificateName");
    }
    public static int CertCompareCertificateName ( int dwCertEncodingType,  Addressable pCertName1,  Addressable pCertName2) {
        var mh$ = CertCompareCertificateName$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pCertName1, pCertName2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertIsRDNAttrsInCertificateName$MH() {
        return RuntimeHelper.requireNonNull(constants$608.CertIsRDNAttrsInCertificateName$MH,"CertIsRDNAttrsInCertificateName");
    }
    public static int CertIsRDNAttrsInCertificateName ( int dwCertEncodingType,  int dwFlags,  Addressable pCertName,  Addressable pRDN) {
        var mh$ = CertIsRDNAttrsInCertificateName$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, dwFlags, pCertName, pRDN);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertComparePublicKeyInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$608.CertComparePublicKeyInfo$MH,"CertComparePublicKeyInfo");
    }
    public static int CertComparePublicKeyInfo ( int dwCertEncodingType,  Addressable pPublicKey1,  Addressable pPublicKey2) {
        var mh$ = CertComparePublicKeyInfo$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pPublicKey1, pPublicKey2);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetPublicKeyLength$MH() {
        return RuntimeHelper.requireNonNull(constants$609.CertGetPublicKeyLength$MH,"CertGetPublicKeyLength");
    }
    public static int CertGetPublicKeyLength ( int dwCertEncodingType,  Addressable pPublicKey) {
        var mh$ = CertGetPublicKeyLength$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pPublicKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyCertificateSignature$MH() {
        return RuntimeHelper.requireNonNull(constants$609.CryptVerifyCertificateSignature$MH,"CryptVerifyCertificateSignature");
    }
    public static int CryptVerifyCertificateSignature ( long hCryptProv,  int dwCertEncodingType,  Addressable pbEncoded,  int cbEncoded,  Addressable pPublicKey) {
        var mh$ = CryptVerifyCertificateSignature$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pPublicKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyCertificateSignatureEx$MH() {
        return RuntimeHelper.requireNonNull(constants$609.CryptVerifyCertificateSignatureEx$MH,"CryptVerifyCertificateSignatureEx");
    }
    public static int CryptVerifyCertificateSignatureEx ( long hCryptProv,  int dwCertEncodingType,  int dwSubjectType,  Addressable pvSubject,  int dwIssuerType,  Addressable pvIssuer,  int dwFlags,  Addressable pvExtra) {
        var mh$ = CryptVerifyCertificateSignatureEx$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, dwSubjectType, pvSubject, dwIssuerType, pvIssuer, dwFlags, pvExtra);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertIsStrongHashToSign$MH() {
        return RuntimeHelper.requireNonNull(constants$609.CertIsStrongHashToSign$MH,"CertIsStrongHashToSign");
    }
    public static int CertIsStrongHashToSign ( Addressable pStrongSignPara,  Addressable pwszCNGHashAlgid,  Addressable pSigningCert) {
        var mh$ = CertIsStrongHashToSign$MH();
        try {
            return (int)mh$.invokeExact(pStrongSignPara, pwszCNGHashAlgid, pSigningCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashToBeSigned$MH() {
        return RuntimeHelper.requireNonNull(constants$609.CryptHashToBeSigned$MH,"CryptHashToBeSigned");
    }
    public static int CryptHashToBeSigned ( long hCryptProv,  int dwCertEncodingType,  Addressable pbEncoded,  int cbEncoded,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptHashToBeSigned$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$609.CryptHashCertificate$MH,"CryptHashCertificate");
    }
    public static int CryptHashCertificate ( long hCryptProv,  int Algid,  int dwFlags,  Addressable pbEncoded,  int cbEncoded,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptHashCertificate$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, Algid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashCertificate2$MH() {
        return RuntimeHelper.requireNonNull(constants$610.CryptHashCertificate2$MH,"CryptHashCertificate2");
    }
    public static int CryptHashCertificate2 ( Addressable pwszCNGHashAlgid,  int dwFlags,  Addressable pvReserved,  Addressable pbEncoded,  int cbEncoded,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptHashCertificate2$MH();
        try {
            return (int)mh$.invokeExact(pwszCNGHashAlgid, dwFlags, pvReserved, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSignCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$610.CryptSignCertificate$MH,"CryptSignCertificate");
    }
    public static int CryptSignCertificate ( long hCryptProvOrNCryptKey,  int dwKeySpec,  int dwCertEncodingType,  Addressable pbEncodedToBeSigned,  int cbEncodedToBeSigned,  Addressable pSignatureAlgorithm,  Addressable pvHashAuxInfo,  Addressable pbSignature,  Addressable pcbSignature) {
        var mh$ = CryptSignCertificate$MH();
        try {
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, pSignatureAlgorithm, pvHashAuxInfo, pbSignature, pcbSignature);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSignAndEncodeCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$610.CryptSignAndEncodeCertificate$MH,"CryptSignAndEncodeCertificate");
    }
    public static int CryptSignAndEncodeCertificate ( long hCryptProvOrNCryptKey,  int dwKeySpec,  int dwCertEncodingType,  Addressable lpszStructType,  Addressable pvStructInfo,  Addressable pSignatureAlgorithm,  Addressable pvHashAuxInfo,  Addressable pbEncoded,  Addressable pcbEncoded) {
        var mh$ = CryptSignAndEncodeCertificate$MH();
        try {
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, lpszStructType, pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertVerifyTimeValidity$MH() {
        return RuntimeHelper.requireNonNull(constants$611.CertVerifyTimeValidity$MH,"CertVerifyTimeValidity");
    }
    public static int CertVerifyTimeValidity ( Addressable pTimeToVerify,  Addressable pCertInfo) {
        var mh$ = CertVerifyTimeValidity$MH();
        try {
            return (int)mh$.invokeExact(pTimeToVerify, pCertInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertVerifyCRLTimeValidity$MH() {
        return RuntimeHelper.requireNonNull(constants$611.CertVerifyCRLTimeValidity$MH,"CertVerifyCRLTimeValidity");
    }
    public static int CertVerifyCRLTimeValidity ( Addressable pTimeToVerify,  Addressable pCrlInfo) {
        var mh$ = CertVerifyCRLTimeValidity$MH();
        try {
            return (int)mh$.invokeExact(pTimeToVerify, pCrlInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertVerifyValidityNesting$MH() {
        return RuntimeHelper.requireNonNull(constants$611.CertVerifyValidityNesting$MH,"CertVerifyValidityNesting");
    }
    public static int CertVerifyValidityNesting ( Addressable pSubjectInfo,  Addressable pIssuerInfo) {
        var mh$ = CertVerifyValidityNesting$MH();
        try {
            return (int)mh$.invokeExact(pSubjectInfo, pIssuerInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertVerifyCRLRevocation$MH() {
        return RuntimeHelper.requireNonNull(constants$612.CertVerifyCRLRevocation$MH,"CertVerifyCRLRevocation");
    }
    public static int CertVerifyCRLRevocation ( int dwCertEncodingType,  Addressable pCertId,  int cCrlInfo,  Addressable rgpCrlInfo) {
        var mh$ = CertVerifyCRLRevocation$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pCertId, cCrlInfo, rgpCrlInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAlgIdToOID$MH() {
        return RuntimeHelper.requireNonNull(constants$612.CertAlgIdToOID$MH,"CertAlgIdToOID");
    }
    public static MemoryAddress CertAlgIdToOID ( int dwAlgId) {
        var mh$ = CertAlgIdToOID$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwAlgId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertOIDToAlgId$MH() {
        return RuntimeHelper.requireNonNull(constants$612.CertOIDToAlgId$MH,"CertOIDToAlgId");
    }
    public static int CertOIDToAlgId ( Addressable pszObjId) {
        var mh$ = CertOIDToAlgId$MH();
        try {
            return (int)mh$.invokeExact(pszObjId);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindExtension$MH() {
        return RuntimeHelper.requireNonNull(constants$612.CertFindExtension$MH,"CertFindExtension");
    }
    public static MemoryAddress CertFindExtension ( Addressable pszObjId,  int cExtensions,  Addressable rgExtensions) {
        var mh$ = CertFindExtension$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pszObjId, cExtensions, rgExtensions);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindAttribute$MH() {
        return RuntimeHelper.requireNonNull(constants$612.CertFindAttribute$MH,"CertFindAttribute");
    }
    public static MemoryAddress CertFindAttribute ( Addressable pszObjId,  int cAttr,  Addressable rgAttr) {
        var mh$ = CertFindAttribute$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pszObjId, cAttr, rgAttr);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFindRDNAttr$MH() {
        return RuntimeHelper.requireNonNull(constants$612.CertFindRDNAttr$MH,"CertFindRDNAttr");
    }
    public static MemoryAddress CertFindRDNAttr ( Addressable pszObjId,  Addressable pName) {
        var mh$ = CertFindRDNAttr$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pszObjId, pName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetIntendedKeyUsage$MH() {
        return RuntimeHelper.requireNonNull(constants$613.CertGetIntendedKeyUsage$MH,"CertGetIntendedKeyUsage");
    }
    public static int CertGetIntendedKeyUsage ( int dwCertEncodingType,  Addressable pCertInfo,  Addressable pbKeyUsage,  int cbKeyUsage) {
        var mh$ = CertGetIntendedKeyUsage$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pCertInfo, pbKeyUsage, cbKeyUsage);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress HCRYPTDEFAULTCONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptInstallDefaultContext$MH() {
        return RuntimeHelper.requireNonNull(constants$613.CryptInstallDefaultContext$MH,"CryptInstallDefaultContext");
    }
    public static int CryptInstallDefaultContext ( long hCryptProv,  int dwDefaultType,  Addressable pvDefaultPara,  int dwFlags,  Addressable pvReserved,  Addressable phDefaultContext) {
        var mh$ = CryptInstallDefaultContext$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, pvReserved, phDefaultContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptUninstallDefaultContext$MH() {
        return RuntimeHelper.requireNonNull(constants$613.CryptUninstallDefaultContext$MH,"CryptUninstallDefaultContext");
    }
    public static int CryptUninstallDefaultContext ( Addressable hDefaultContext,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CryptUninstallDefaultContext$MH();
        try {
            return (int)mh$.invokeExact(hDefaultContext, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportPublicKeyInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$613.CryptExportPublicKeyInfo$MH,"CryptExportPublicKeyInfo");
    }
    public static int CryptExportPublicKeyInfo ( long hCryptProvOrNCryptKey,  int dwKeySpec,  int dwCertEncodingType,  Addressable pInfo,  Addressable pcbInfo) {
        var mh$ = CryptExportPublicKeyInfo$MH();
        try {
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportPublicKeyInfoEx$MH() {
        return RuntimeHelper.requireNonNull(constants$613.CryptExportPublicKeyInfoEx$MH,"CryptExportPublicKeyInfoEx");
    }
    public static int CryptExportPublicKeyInfoEx ( long hCryptProvOrNCryptKey,  int dwKeySpec,  int dwCertEncodingType,  Addressable pszPublicKeyObjId,  int dwFlags,  Addressable pvAuxInfo,  Addressable pInfo,  Addressable pcbInfo) {
        var mh$ = CryptExportPublicKeyInfoEx$MH();
        try {
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportPublicKeyInfoFromBCryptKeyHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$614.CryptExportPublicKeyInfoFromBCryptKeyHandle$MH,"CryptExportPublicKeyInfoFromBCryptKeyHandle");
    }
    public static int CryptExportPublicKeyInfoFromBCryptKeyHandle ( Addressable hBCryptKey,  int dwCertEncodingType,  Addressable pszPublicKeyObjId,  int dwFlags,  Addressable pvAuxInfo,  Addressable pInfo,  Addressable pcbInfo) {
        var mh$ = CryptExportPublicKeyInfoFromBCryptKeyHandle$MH();
        try {
            return (int)mh$.invokeExact(hBCryptKey, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptImportPublicKeyInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$614.CryptImportPublicKeyInfo$MH,"CryptImportPublicKeyInfo");
    }
    public static int CryptImportPublicKeyInfo ( long hCryptProv,  int dwCertEncodingType,  Addressable pInfo,  Addressable phKey) {
        var mh$ = CryptImportPublicKeyInfo$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pInfo, phKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptImportPublicKeyInfoEx$MH() {
        return RuntimeHelper.requireNonNull(constants$614.CryptImportPublicKeyInfoEx$MH,"CryptImportPublicKeyInfoEx");
    }
    public static int CryptImportPublicKeyInfoEx ( long hCryptProv,  int dwCertEncodingType,  Addressable pInfo,  int aiKeyAlg,  int dwFlags,  Addressable pvAuxInfo,  Addressable phKey) {
        var mh$ = CryptImportPublicKeyInfoEx$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pInfo, aiKeyAlg, dwFlags, pvAuxInfo, phKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptImportPublicKeyInfoEx2$MH() {
        return RuntimeHelper.requireNonNull(constants$615.CryptImportPublicKeyInfoEx2$MH,"CryptImportPublicKeyInfoEx2");
    }
    public static int CryptImportPublicKeyInfoEx2 ( int dwCertEncodingType,  Addressable pInfo,  int dwFlags,  Addressable pvAuxInfo,  Addressable phKey) {
        var mh$ = CryptImportPublicKeyInfoEx2$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pInfo, dwFlags, pvAuxInfo, phKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptAcquireCertificatePrivateKey$MH() {
        return RuntimeHelper.requireNonNull(constants$615.CryptAcquireCertificatePrivateKey$MH,"CryptAcquireCertificatePrivateKey");
    }
    public static int CryptAcquireCertificatePrivateKey ( Addressable pCert,  int dwFlags,  Addressable pvParameters,  Addressable phCryptProvOrNCryptKey,  Addressable pdwKeySpec,  Addressable pfCallerFreeProvOrNCryptKey) {
        var mh$ = CryptAcquireCertificatePrivateKey$MH();
        try {
            return (int)mh$.invokeExact(pCert, dwFlags, pvParameters, phCryptProvOrNCryptKey, pdwKeySpec, pfCallerFreeProvOrNCryptKey);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptFindCertificateKeyProvInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$615.CryptFindCertificateKeyProvInfo$MH,"CryptFindCertificateKeyProvInfo");
    }
    public static int CryptFindCertificateKeyProvInfo ( Addressable pCert,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CryptFindCertificateKeyProvInfo$MH();
        try {
            return (int)mh$.invokeExact(pCert, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptImportPKCS8$MH() {
        return RuntimeHelper.requireNonNull(constants$616.CryptImportPKCS8$MH,"CryptImportPKCS8");
    }
    public static int CryptImportPKCS8 ( MemorySegment sPrivateKeyAndParams,  int dwFlags,  Addressable phCryptProv,  Addressable pvAuxInfo) {
        var mh$ = CryptImportPKCS8$MH();
        try {
            return (int)mh$.invokeExact(sPrivateKeyAndParams, dwFlags, phCryptProv, pvAuxInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportPKCS8$MH() {
        return RuntimeHelper.requireNonNull(constants$616.CryptExportPKCS8$MH,"CryptExportPKCS8");
    }
    public static int CryptExportPKCS8 ( long hCryptProv,  int dwKeySpec,  Addressable pszPrivateKeyObjId,  int dwFlags,  Addressable pvAuxInfo,  Addressable pbPrivateKeyBlob,  Addressable pcbPrivateKeyBlob) {
        var mh$ = CryptExportPKCS8$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, dwKeySpec, pszPrivateKeyObjId, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptExportPKCS8Ex$MH() {
        return RuntimeHelper.requireNonNull(constants$616.CryptExportPKCS8Ex$MH,"CryptExportPKCS8Ex");
    }
    public static int CryptExportPKCS8Ex ( Addressable psExportParams,  int dwFlags,  Addressable pvAuxInfo,  Addressable pbPrivateKeyBlob,  Addressable pcbPrivateKeyBlob) {
        var mh$ = CryptExportPKCS8Ex$MH();
        try {
            return (int)mh$.invokeExact(psExportParams, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashPublicKeyInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$617.CryptHashPublicKeyInfo$MH,"CryptHashPublicKeyInfo");
    }
    public static int CryptHashPublicKeyInfo ( long hCryptProv,  int Algid,  int dwFlags,  int dwCertEncodingType,  Addressable pInfo,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptHashPublicKeyInfo$MH();
        try {
            return (int)mh$.invokeExact(hCryptProv, Algid, dwFlags, dwCertEncodingType, pInfo, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRDNValueToStrA$MH() {
        return RuntimeHelper.requireNonNull(constants$617.CertRDNValueToStrA$MH,"CertRDNValueToStrA");
    }
    public static int CertRDNValueToStrA ( int dwValueType,  Addressable pValue,  Addressable psz,  int csz) {
        var mh$ = CertRDNValueToStrA$MH();
        try {
            return (int)mh$.invokeExact(dwValueType, pValue, psz, csz);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRDNValueToStrW$MH() {
        return RuntimeHelper.requireNonNull(constants$617.CertRDNValueToStrW$MH,"CertRDNValueToStrW");
    }
    public static int CertRDNValueToStrW ( int dwValueType,  Addressable pValue,  Addressable psz,  int csz) {
        var mh$ = CertRDNValueToStrW$MH();
        try {
            return (int)mh$.invokeExact(dwValueType, pValue, psz, csz);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertNameToStrA$MH() {
        return RuntimeHelper.requireNonNull(constants$617.CertNameToStrA$MH,"CertNameToStrA");
    }
    public static int CertNameToStrA ( int dwCertEncodingType,  Addressable pName,  int dwStrType,  Addressable psz,  int csz) {
        var mh$ = CertNameToStrA$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pName, dwStrType, psz, csz);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertNameToStrW$MH() {
        return RuntimeHelper.requireNonNull(constants$617.CertNameToStrW$MH,"CertNameToStrW");
    }
    public static int CertNameToStrW ( int dwCertEncodingType,  Addressable pName,  int dwStrType,  Addressable psz,  int csz) {
        var mh$ = CertNameToStrW$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pName, dwStrType, psz, csz);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertStrToNameA$MH() {
        return RuntimeHelper.requireNonNull(constants$617.CertStrToNameA$MH,"CertStrToNameA");
    }
    public static int CertStrToNameA ( int dwCertEncodingType,  Addressable pszX500,  int dwStrType,  Addressable pvReserved,  Addressable pbEncoded,  Addressable pcbEncoded,  Addressable ppszError) {
        var mh$ = CertStrToNameA$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertStrToNameW$MH() {
        return RuntimeHelper.requireNonNull(constants$618.CertStrToNameW$MH,"CertStrToNameW");
    }
    public static int CertStrToNameW ( int dwCertEncodingType,  Addressable pszX500,  int dwStrType,  Addressable pvReserved,  Addressable pbEncoded,  Addressable pcbEncoded,  Addressable ppszError) {
        var mh$ = CertStrToNameW$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetNameStringA$MH() {
        return RuntimeHelper.requireNonNull(constants$618.CertGetNameStringA$MH,"CertGetNameStringA");
    }
    public static int CertGetNameStringA ( Addressable pCertContext,  int dwType,  int dwFlags,  Addressable pvTypePara,  Addressable pszNameString,  int cchNameString) {
        var mh$ = CertGetNameStringA$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetNameStringW$MH() {
        return RuntimeHelper.requireNonNull(constants$618.CertGetNameStringW$MH,"CertGetNameStringW");
    }
    public static int CertGetNameStringW ( Addressable pCertContext,  int dwType,  int dwFlags,  Addressable pvTypePara,  Addressable pszNameString,  int cchNameString) {
        var mh$ = CertGetNameStringW$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_SIGN_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_VERIFY_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_ENCRYPT_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_DECRYPT_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_HASH_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_KEY_SIGN_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_KEY_VERIFY_MESSAGE_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptSignMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$618.CryptSignMessage$MH,"CryptSignMessage");
    }
    public static int CryptSignMessage ( Addressable pSignPara,  int fDetachedSignature,  int cToBeSigned,  Addressable rgpbToBeSigned,  Addressable rgcbToBeSigned,  Addressable pbSignedBlob,  Addressable pcbSignedBlob) {
        var mh$ = CryptSignMessage$MH();
        try {
            return (int)mh$.invokeExact(pSignPara, fDetachedSignature, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, pbSignedBlob, pcbSignedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyMessageSignature$MH() {
        return RuntimeHelper.requireNonNull(constants$619.CryptVerifyMessageSignature$MH,"CryptVerifyMessageSignature");
    }
    public static int CryptVerifyMessageSignature ( Addressable pVerifyPara,  int dwSignerIndex,  Addressable pbSignedBlob,  int cbSignedBlob,  Addressable pbDecoded,  Addressable pcbDecoded,  Addressable ppSignerCert) {
        var mh$ = CryptVerifyMessageSignature$MH();
        try {
            return (int)mh$.invokeExact(pVerifyPara, dwSignerIndex, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded, ppSignerCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetMessageSignerCount$MH() {
        return RuntimeHelper.requireNonNull(constants$619.CryptGetMessageSignerCount$MH,"CryptGetMessageSignerCount");
    }
    public static int CryptGetMessageSignerCount ( int dwMsgEncodingType,  Addressable pbSignedBlob,  int cbSignedBlob) {
        var mh$ = CryptGetMessageSignerCount$MH();
        try {
            return (int)mh$.invokeExact(dwMsgEncodingType, pbSignedBlob, cbSignedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetMessageCertificates$MH() {
        return RuntimeHelper.requireNonNull(constants$619.CryptGetMessageCertificates$MH,"CryptGetMessageCertificates");
    }
    public static MemoryAddress CryptGetMessageCertificates ( int dwMsgAndCertEncodingType,  long hCryptProv,  int dwFlags,  Addressable pbSignedBlob,  int cbSignedBlob) {
        var mh$ = CryptGetMessageCertificates$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(dwMsgAndCertEncodingType, hCryptProv, dwFlags, pbSignedBlob, cbSignedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyDetachedMessageSignature$MH() {
        return RuntimeHelper.requireNonNull(constants$619.CryptVerifyDetachedMessageSignature$MH,"CryptVerifyDetachedMessageSignature");
    }
    public static int CryptVerifyDetachedMessageSignature ( Addressable pVerifyPara,  int dwSignerIndex,  Addressable pbDetachedSignBlob,  int cbDetachedSignBlob,  int cToBeSigned,  Addressable rgpbToBeSigned,  Addressable rgcbToBeSigned,  Addressable ppSignerCert) {
        var mh$ = CryptVerifyDetachedMessageSignature$MH();
        try {
            return (int)mh$.invokeExact(pVerifyPara, dwSignerIndex, pbDetachedSignBlob, cbDetachedSignBlob, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, ppSignerCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEncryptMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$619.CryptEncryptMessage$MH,"CryptEncryptMessage");
    }
    public static int CryptEncryptMessage ( Addressable pEncryptPara,  int cRecipientCert,  Addressable rgpRecipientCert,  Addressable pbToBeEncrypted,  int cbToBeEncrypted,  Addressable pbEncryptedBlob,  Addressable pcbEncryptedBlob) {
        var mh$ = CryptEncryptMessage$MH();
        try {
            return (int)mh$.invokeExact(pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeEncrypted, cbToBeEncrypted, pbEncryptedBlob, pcbEncryptedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDecryptMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$619.CryptDecryptMessage$MH,"CryptDecryptMessage");
    }
    public static int CryptDecryptMessage ( Addressable pDecryptPara,  Addressable pbEncryptedBlob,  int cbEncryptedBlob,  Addressable pbDecrypted,  Addressable pcbDecrypted,  Addressable ppXchgCert) {
        var mh$ = CryptDecryptMessage$MH();
        try {
            return (int)mh$.invokeExact(pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSignAndEncryptMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$620.CryptSignAndEncryptMessage$MH,"CryptSignAndEncryptMessage");
    }
    public static int CryptSignAndEncryptMessage ( Addressable pSignPara,  Addressable pEncryptPara,  int cRecipientCert,  Addressable rgpRecipientCert,  Addressable pbToBeSignedAndEncrypted,  int cbToBeSignedAndEncrypted,  Addressable pbSignedAndEncryptedBlob,  Addressable pcbSignedAndEncryptedBlob) {
        var mh$ = CryptSignAndEncryptMessage$MH();
        try {
            return (int)mh$.invokeExact(pSignPara, pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDecryptAndVerifyMessageSignature$MH() {
        return RuntimeHelper.requireNonNull(constants$620.CryptDecryptAndVerifyMessageSignature$MH,"CryptDecryptAndVerifyMessageSignature");
    }
    public static int CryptDecryptAndVerifyMessageSignature ( Addressable pDecryptPara,  Addressable pVerifyPara,  int dwSignerIndex,  Addressable pbEncryptedBlob,  int cbEncryptedBlob,  Addressable pbDecrypted,  Addressable pcbDecrypted,  Addressable ppXchgCert,  Addressable ppSignerCert) {
        var mh$ = CryptDecryptAndVerifyMessageSignature$MH();
        try {
            return (int)mh$.invokeExact(pDecryptPara, pVerifyPara, dwSignerIndex, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert, ppSignerCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptDecodeMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$620.CryptDecodeMessage$MH,"CryptDecodeMessage");
    }
    public static int CryptDecodeMessage ( int dwMsgTypeFlags,  Addressable pDecryptPara,  Addressable pVerifyPara,  int dwSignerIndex,  Addressable pbEncodedBlob,  int cbEncodedBlob,  int dwPrevInnerContentType,  Addressable pdwMsgType,  Addressable pdwInnerContentType,  Addressable pbDecoded,  Addressable pcbDecoded,  Addressable ppXchgCert,  Addressable ppSignerCert) {
        var mh$ = CryptDecodeMessage$MH();
        try {
            return (int)mh$.invokeExact(dwMsgTypeFlags, pDecryptPara, pVerifyPara, dwSignerIndex, pbEncodedBlob, cbEncodedBlob, dwPrevInnerContentType, pdwMsgType, pdwInnerContentType, pbDecoded, pcbDecoded, ppXchgCert, ppSignerCert);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptHashMessage$MH() {
        return RuntimeHelper.requireNonNull(constants$620.CryptHashMessage$MH,"CryptHashMessage");
    }
    public static int CryptHashMessage ( Addressable pHashPara,  int fDetachedHash,  int cToBeHashed,  Addressable rgpbToBeHashed,  Addressable rgcbToBeHashed,  Addressable pbHashedBlob,  Addressable pcbHashedBlob,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptHashMessage$MH();
        try {
            return (int)mh$.invokeExact(pHashPara, fDetachedHash, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbHashedBlob, pcbHashedBlob, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyMessageHash$MH() {
        return RuntimeHelper.requireNonNull(constants$620.CryptVerifyMessageHash$MH,"CryptVerifyMessageHash");
    }
    public static int CryptVerifyMessageHash ( Addressable pHashPara,  Addressable pbHashedBlob,  int cbHashedBlob,  Addressable pbToBeHashed,  Addressable pcbToBeHashed,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptVerifyMessageHash$MH();
        try {
            return (int)mh$.invokeExact(pHashPara, pbHashedBlob, cbHashedBlob, pbToBeHashed, pcbToBeHashed, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyDetachedMessageHash$MH() {
        return RuntimeHelper.requireNonNull(constants$620.CryptVerifyDetachedMessageHash$MH,"CryptVerifyDetachedMessageHash");
    }
    public static int CryptVerifyDetachedMessageHash ( Addressable pHashPara,  Addressable pbDetachedHashBlob,  int cbDetachedHashBlob,  int cToBeHashed,  Addressable rgpbToBeHashed,  Addressable rgcbToBeHashed,  Addressable pbComputedHash,  Addressable pcbComputedHash) {
        var mh$ = CryptVerifyDetachedMessageHash$MH();
        try {
            return (int)mh$.invokeExact(pHashPara, pbDetachedHashBlob, cbDetachedHashBlob, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSignMessageWithKey$MH() {
        return RuntimeHelper.requireNonNull(constants$621.CryptSignMessageWithKey$MH,"CryptSignMessageWithKey");
    }
    public static int CryptSignMessageWithKey ( Addressable pSignPara,  Addressable pbToBeSigned,  int cbToBeSigned,  Addressable pbSignedBlob,  Addressable pcbSignedBlob) {
        var mh$ = CryptSignMessageWithKey$MH();
        try {
            return (int)mh$.invokeExact(pSignPara, pbToBeSigned, cbToBeSigned, pbSignedBlob, pcbSignedBlob);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyMessageSignatureWithKey$MH() {
        return RuntimeHelper.requireNonNull(constants$621.CryptVerifyMessageSignatureWithKey$MH,"CryptVerifyMessageSignatureWithKey");
    }
    public static int CryptVerifyMessageSignatureWithKey ( Addressable pVerifyPara,  Addressable pPublicKeyInfo,  Addressable pbSignedBlob,  int cbSignedBlob,  Addressable pbDecoded,  Addressable pcbDecoded) {
        var mh$ = CryptVerifyMessageSignatureWithKey$MH();
        try {
            return (int)mh$.invokeExact(pVerifyPara, pPublicKeyInfo, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertOpenSystemStoreA$MH() {
        return RuntimeHelper.requireNonNull(constants$621.CertOpenSystemStoreA$MH,"CertOpenSystemStoreA");
    }
    public static MemoryAddress CertOpenSystemStoreA ( long hProv,  Addressable szSubsystemProtocol) {
        var mh$ = CertOpenSystemStoreA$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hProv, szSubsystemProtocol);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertOpenSystemStoreW$MH() {
        return RuntimeHelper.requireNonNull(constants$621.CertOpenSystemStoreW$MH,"CertOpenSystemStoreW");
    }
    public static MemoryAddress CertOpenSystemStoreW ( long hProv,  Addressable szSubsystemProtocol) {
        var mh$ = CertOpenSystemStoreW$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hProv, szSubsystemProtocol);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddEncodedCertificateToSystemStoreA$MH() {
        return RuntimeHelper.requireNonNull(constants$621.CertAddEncodedCertificateToSystemStoreA$MH,"CertAddEncodedCertificateToSystemStoreA");
    }
    public static int CertAddEncodedCertificateToSystemStoreA ( Addressable szCertStoreName,  Addressable pbCertEncoded,  int cbCertEncoded) {
        var mh$ = CertAddEncodedCertificateToSystemStoreA$MH();
        try {
            return (int)mh$.invokeExact(szCertStoreName, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddEncodedCertificateToSystemStoreW$MH() {
        return RuntimeHelper.requireNonNull(constants$621.CertAddEncodedCertificateToSystemStoreW$MH,"CertAddEncodedCertificateToSystemStoreW");
    }
    public static int CertAddEncodedCertificateToSystemStoreW ( Addressable szCertStoreName,  Addressable pbCertEncoded,  int cbCertEncoded) {
        var mh$ = CertAddEncodedCertificateToSystemStoreW$MH();
        try {
            return (int)mh$.invokeExact(szCertStoreName, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_CHAIN = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle FindCertsByIssuer$MH() {
        return RuntimeHelper.requireNonNull(constants$622.FindCertsByIssuer$MH,"FindCertsByIssuer");
    }
    public static int FindCertsByIssuer ( Addressable pCertChains,  Addressable pcbCertChains,  Addressable pcCertChains,  Addressable pbEncodedIssuerName,  int cbEncodedIssuerName,  Addressable pwszPurpose,  int dwKeySpec) {
        var mh$ = FindCertsByIssuer$MH();
        try {
            return (int)mh$.invokeExact(pCertChains, pcbCertChains, pcCertChains, pbEncodedIssuerName, cbEncodedIssuerName, pwszPurpose, dwKeySpec);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptQueryObject$MH() {
        return RuntimeHelper.requireNonNull(constants$622.CryptQueryObject$MH,"CryptQueryObject");
    }
    public static int CryptQueryObject ( int dwObjectType,  Addressable pvObject,  int dwExpectedContentTypeFlags,  int dwExpectedFormatTypeFlags,  int dwFlags,  Addressable pdwMsgAndCertEncodingType,  Addressable pdwContentType,  Addressable pdwFormatType,  Addressable phCertStore,  Addressable phMsg,  Addressable ppvContext) {
        var mh$ = CryptQueryObject$MH();
        try {
            return (int)mh$.invokeExact(dwObjectType, pvObject, dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, pdwMsgAndCertEncodingType, pdwContentType, pdwFormatType, phCertStore, phMsg, ppvContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMemAlloc$MH() {
        return RuntimeHelper.requireNonNull(constants$622.CryptMemAlloc$MH,"CryptMemAlloc");
    }
    public static MemoryAddress CryptMemAlloc ( int cbSize) {
        var mh$ = CryptMemAlloc$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(cbSize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMemRealloc$MH() {
        return RuntimeHelper.requireNonNull(constants$622.CryptMemRealloc$MH,"CryptMemRealloc");
    }
    public static MemoryAddress CryptMemRealloc ( Addressable pv,  int cbSize) {
        var mh$ = CryptMemRealloc$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pv, cbSize);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptMemFree$MH() {
        return RuntimeHelper.requireNonNull(constants$622.CryptMemFree$MH,"CryptMemFree");
    }
    public static void CryptMemFree ( Addressable pv) {
        var mh$ = CryptMemFree$MH();
        try {
            mh$.invokeExact(pv);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress HCRYPTASYNC = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PHCRYPTASYNC = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptCreateAsyncHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$623.CryptCreateAsyncHandle$MH,"CryptCreateAsyncHandle");
    }
    public static int CryptCreateAsyncHandle ( int dwFlags,  Addressable phAsync) {
        var mh$ = CryptCreateAsyncHandle$MH();
        try {
            return (int)mh$.invokeExact(dwFlags, phAsync);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetAsyncParam$MH() {
        return RuntimeHelper.requireNonNull(constants$623.CryptSetAsyncParam$MH,"CryptSetAsyncParam");
    }
    public static int CryptSetAsyncParam ( Addressable hAsync,  Addressable pszParamOid,  Addressable pvParam,  Addressable pfnFree) {
        var mh$ = CryptSetAsyncParam$MH();
        try {
            return (int)mh$.invokeExact(hAsync, pszParamOid, pvParam, pfnFree);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetAsyncParam$MH() {
        return RuntimeHelper.requireNonNull(constants$623.CryptGetAsyncParam$MH,"CryptGetAsyncParam");
    }
    public static int CryptGetAsyncParam ( Addressable hAsync,  Addressable pszParamOid,  Addressable ppvParam,  Addressable ppfnFree) {
        var mh$ = CryptGetAsyncParam$MH();
        try {
            return (int)mh$.invokeExact(hAsync, pszParamOid, ppvParam, ppfnFree);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptCloseAsyncHandle$MH() {
        return RuntimeHelper.requireNonNull(constants$623.CryptCloseAsyncHandle$MH,"CryptCloseAsyncHandle");
    }
    public static int CryptCloseAsyncHandle ( Addressable hAsync) {
        var mh$ = CryptCloseAsyncHandle$MH();
        try {
            return (int)mh$.invokeExact(hAsync);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_BLOB_ARRAY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_CREDENTIALS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PASSWORD_CREDENTIALSA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PASSWORD_CREDENTIALSW = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_PASSWORD_CREDENTIALS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPTNET_URL_CACHE_PRE_FETCH_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPTNET_URL_CACHE_FLUSH_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPTNET_URL_CACHE_RESPONSE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_RETRIEVE_AUX_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptRetrieveObjectByUrlA$MH() {
        return RuntimeHelper.requireNonNull(constants$624.CryptRetrieveObjectByUrlA$MH,"CryptRetrieveObjectByUrlA");
    }
    public static int CryptRetrieveObjectByUrlA ( Addressable pszUrl,  Addressable pszObjectOid,  int dwRetrievalFlags,  int dwTimeout,  Addressable ppvObject,  Addressable hAsyncRetrieve,  Addressable pCredentials,  Addressable pvVerify,  Addressable pAuxInfo) {
        var mh$ = CryptRetrieveObjectByUrlA$MH();
        try {
            return (int)mh$.invokeExact(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptRetrieveObjectByUrlW$MH() {
        return RuntimeHelper.requireNonNull(constants$624.CryptRetrieveObjectByUrlW$MH,"CryptRetrieveObjectByUrlW");
    }
    public static int CryptRetrieveObjectByUrlW ( Addressable pszUrl,  Addressable pszObjectOid,  int dwRetrievalFlags,  int dwTimeout,  Addressable ppvObject,  Addressable hAsyncRetrieve,  Addressable pCredentials,  Addressable pvVerify,  Addressable pAuxInfo) {
        var mh$ = CryptRetrieveObjectByUrlW$MH();
        try {
            return (int)mh$.invokeExact(pszUrl, pszObjectOid, dwRetrievalFlags, dwTimeout, ppvObject, hAsyncRetrieve, pCredentials, pvVerify, pAuxInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptInstallCancelRetrieval$MH() {
        return RuntimeHelper.requireNonNull(constants$624.CryptInstallCancelRetrieval$MH,"CryptInstallCancelRetrieval");
    }
    public static int CryptInstallCancelRetrieval ( Addressable pfnCancel,  Addressable pvArg,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CryptInstallCancelRetrieval$MH();
        try {
            return (int)mh$.invokeExact(pfnCancel, pvArg, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUninstallCancelRetrieval$MH() {
        return RuntimeHelper.requireNonNull(constants$625.CryptUninstallCancelRetrieval$MH,"CryptUninstallCancelRetrieval");
    }
    public static int CryptUninstallCancelRetrieval ( int dwFlags,  Addressable pvReserved) {
        var mh$ = CryptUninstallCancelRetrieval$MH();
        try {
            return (int)mh$.invokeExact(dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptCancelAsyncRetrieval$MH() {
        return RuntimeHelper.requireNonNull(constants$625.CryptCancelAsyncRetrieval$MH,"CryptCancelAsyncRetrieval");
    }
    public static int CryptCancelAsyncRetrieval ( Addressable hAsyncRetrieval) {
        var mh$ = CryptCancelAsyncRetrieval$MH();
        try {
            return (int)mh$.invokeExact(hAsyncRetrieval);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_ASYNC_RETRIEVAL_COMPLETION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_URL_ARRAY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_URL_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptGetObjectUrl$MH() {
        return RuntimeHelper.requireNonNull(constants$626.CryptGetObjectUrl$MH,"CryptGetObjectUrl");
    }
    public static int CryptGetObjectUrl ( Addressable pszUrlOid,  Addressable pvPara,  int dwFlags,  Addressable pUrlArray,  Addressable pcbUrlArray,  Addressable pUrlInfo,  Addressable pcbUrlInfo,  Addressable pvReserved) {
        var mh$ = CryptGetObjectUrl$MH();
        try {
            return (int)mh$.invokeExact(pszUrlOid, pvPara, dwFlags, pUrlArray, pcbUrlArray, pUrlInfo, pcbUrlInfo, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_CRL_CONTEXT_PAIR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_CRL_CONTEXT_PAIR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptGetTimeValidObject$MH() {
        return RuntimeHelper.requireNonNull(constants$626.CryptGetTimeValidObject$MH,"CryptGetTimeValidObject");
    }
    public static int CryptGetTimeValidObject ( Addressable pszTimeValidOid,  Addressable pvPara,  Addressable pIssuer,  Addressable pftValidFor,  int dwFlags,  int dwTimeout,  Addressable ppvObject,  Addressable pCredentials,  Addressable pExtraInfo) {
        var mh$ = CryptGetTimeValidObject$MH();
        try {
            return (int)mh$.invokeExact(pszTimeValidOid, pvPara, pIssuer, pftValidFor, dwFlags, dwTimeout, ppvObject, pCredentials, pExtraInfo);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptFlushTimeValidObject$MH() {
        return RuntimeHelper.requireNonNull(constants$626.CryptFlushTimeValidObject$MH,"CryptFlushTimeValidObject");
    }
    public static int CryptFlushTimeValidObject ( Addressable pszFlushTimeValidOid,  Addressable pvPara,  Addressable pIssuer,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CryptFlushTimeValidObject$MH();
        try {
            return (int)mh$.invokeExact(pszFlushTimeValidOid, pvPara, pIssuer, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCreateSelfSignCertificate$MH() {
        return RuntimeHelper.requireNonNull(constants$626.CertCreateSelfSignCertificate$MH,"CertCreateSelfSignCertificate");
    }
    public static MemoryAddress CertCreateSelfSignCertificate ( long hCryptProvOrNCryptKey,  Addressable pSubjectIssuerBlob,  int dwFlags,  Addressable pKeyProvInfo,  Addressable pSignatureAlgorithm,  Addressable pStartTime,  Addressable pEndTime,  Addressable pExtensions) {
        var mh$ = CertCreateSelfSignCertificate$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCryptProvOrNCryptKey, pSubjectIssuerBlob, dwFlags, pKeyProvInfo, pSignatureAlgorithm, pStartTime, pEndTime, pExtensions);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptGetKeyIdentifierProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$626.CryptGetKeyIdentifierProperty$MH,"CryptGetKeyIdentifierProperty");
    }
    public static int CryptGetKeyIdentifierProperty ( Addressable pKeyIdentifier,  int dwPropId,  int dwFlags,  Addressable pwszComputerName,  Addressable pvReserved,  Addressable pvData,  Addressable pcbData) {
        var mh$ = CryptGetKeyIdentifierProperty$MH();
        try {
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData, pcbData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptSetKeyIdentifierProperty$MH() {
        return RuntimeHelper.requireNonNull(constants$626.CryptSetKeyIdentifierProperty$MH,"CryptSetKeyIdentifierProperty");
    }
    public static int CryptSetKeyIdentifierProperty ( Addressable pKeyIdentifier,  int dwPropId,  int dwFlags,  Addressable pwszComputerName,  Addressable pvReserved,  Addressable pvData) {
        var mh$ = CryptSetKeyIdentifierProperty$MH();
        try {
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvData);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptEnumKeyIdentifierProperties$MH() {
        return RuntimeHelper.requireNonNull(constants$627.CryptEnumKeyIdentifierProperties$MH,"CryptEnumKeyIdentifierProperties");
    }
    public static int CryptEnumKeyIdentifierProperties ( Addressable pKeyIdentifier,  int dwPropId,  int dwFlags,  Addressable pwszComputerName,  Addressable pvReserved,  Addressable pvArg,  Addressable pfnEnum) {
        var mh$ = CryptEnumKeyIdentifierProperties$MH();
        try {
            return (int)mh$.invokeExact(pKeyIdentifier, dwPropId, dwFlags, pwszComputerName, pvReserved, pvArg, pfnEnum);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptCreateKeyIdentifierFromCSP$MH() {
        return RuntimeHelper.requireNonNull(constants$627.CryptCreateKeyIdentifierFromCSP$MH,"CryptCreateKeyIdentifierFromCSP");
    }
    public static int CryptCreateKeyIdentifierFromCSP ( int dwCertEncodingType,  Addressable pszPubKeyOID,  Addressable pPubKeyStruc,  int cbPubKeyStruc,  int dwFlags,  Addressable pvReserved,  Addressable pbHash,  Addressable pcbHash) {
        var mh$ = CryptCreateKeyIdentifierFromCSP$MH();
        try {
            return (int)mh$.invokeExact(dwCertEncodingType, pszPubKeyOID, pPubKeyStruc, cbPubKeyStruc, dwFlags, pvReserved, pbHash, pcbHash);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress HCERTCHAINENGINE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_ENGINE_CONFIG = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertCreateCertificateChainEngine$MH() {
        return RuntimeHelper.requireNonNull(constants$627.CertCreateCertificateChainEngine$MH,"CertCreateCertificateChainEngine");
    }
    public static int CertCreateCertificateChainEngine ( Addressable pConfig,  Addressable phChainEngine) {
        var mh$ = CertCreateCertificateChainEngine$MH();
        try {
            return (int)mh$.invokeExact(pConfig, phChainEngine);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCertificateChainEngine$MH() {
        return RuntimeHelper.requireNonNull(constants$627.CertFreeCertificateChainEngine$MH,"CertFreeCertificateChainEngine");
    }
    public static void CertFreeCertificateChainEngine ( Addressable hChainEngine) {
        var mh$ = CertFreeCertificateChainEngine$MH();
        try {
            mh$.invokeExact(hChainEngine);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertResyncCertificateChainEngine$MH() {
        return RuntimeHelper.requireNonNull(constants$628.CertResyncCertificateChainEngine$MH,"CertResyncCertificateChainEngine");
    }
    public static int CertResyncCertificateChainEngine ( Addressable hChainEngine) {
        var mh$ = CertResyncCertificateChainEngine$MH();
        try {
            return (int)mh$.invokeExact(hChainEngine);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_TRUST_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_REVOCATION_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_TRUST_LIST_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_ELEMENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_CHAIN_ELEMENT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SIMPLE_CHAIN = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_SIMPLE_CHAIN = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_CHAIN_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_USAGE_MATCH = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCTL_USAGE_MATCH = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertGetCertificateChain$MH() {
        return RuntimeHelper.requireNonNull(constants$628.CertGetCertificateChain$MH,"CertGetCertificateChain");
    }
    public static int CertGetCertificateChain ( Addressable hChainEngine,  Addressable pCertContext,  Addressable pTime,  Addressable hAdditionalStore,  Addressable pChainPara,  int dwFlags,  Addressable pvReserved,  Addressable ppChainContext) {
        var mh$ = CertGetCertificateChain$MH();
        try {
            return (int)mh$.invokeExact(hChainEngine, pCertContext, pTime, hAdditionalStore, pChainPara, dwFlags, pvReserved, ppChainContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCertificateChain$MH() {
        return RuntimeHelper.requireNonNull(constants$628.CertFreeCertificateChain$MH,"CertFreeCertificateChain");
    }
    public static void CertFreeCertificateChain ( Addressable pChainContext) {
        var mh$ = CertFreeCertificateChain$MH();
        try {
            mh$.invokeExact(pChainContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertDuplicateCertificateChain$MH() {
        return RuntimeHelper.requireNonNull(constants$628.CertDuplicateCertificateChain$MH,"CertDuplicateCertificateChain");
    }
    public static MemoryAddress CertDuplicateCertificateChain ( Addressable pChainContext) {
        var mh$ = CertDuplicateCertificateChain$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pChainContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRL_REVOCATION_INFO = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertFindChainInStore$MH() {
        return RuntimeHelper.requireNonNull(constants$628.CertFindChainInStore$MH,"CertFindChainInStore");
    }
    public static MemoryAddress CertFindChainInStore ( Addressable hCertStore,  int dwCertEncodingType,  int dwFindFlags,  int dwFindType,  Addressable pvFindPara,  Addressable pPrevChainContext) {
        var mh$ = CertFindChainInStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevChainContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_CHAIN_FIND_ISSUER_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_FIND_BY_ISSUER_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_CHAIN_POLICY_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertVerifyCertificateChainPolicy$MH() {
        return RuntimeHelper.requireNonNull(constants$629.CertVerifyCertificateChainPolicy$MH,"CertVerifyCertificateChainPolicy");
    }
    public static int CertVerifyCertificateChainPolicy ( Addressable pszPolicyOID,  Addressable pChainContext,  Addressable pPolicyPara,  Addressable pPolicyStatus) {
        var mh$ = CertVerifyCertificateChainPolicy$MH();
        try {
            return (int)mh$.invokeExact(pszPolicyOID, pChainContext, pPolicyPara, pPolicyStatus);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PHTTPSPolicyCallbackData = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEV_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEV_EXTRA_CERT_CHAIN_POLICY_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptStringToBinaryA$MH() {
        return RuntimeHelper.requireNonNull(constants$629.CryptStringToBinaryA$MH,"CryptStringToBinaryA");
    }
    public static int CryptStringToBinaryA ( Addressable pszString,  int cchString,  int dwFlags,  Addressable pbBinary,  Addressable pcbBinary,  Addressable pdwSkip,  Addressable pdwFlags) {
        var mh$ = CryptStringToBinaryA$MH();
        try {
            return (int)mh$.invokeExact(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptStringToBinaryW$MH() {
        return RuntimeHelper.requireNonNull(constants$629.CryptStringToBinaryW$MH,"CryptStringToBinaryW");
    }
    public static int CryptStringToBinaryW ( Addressable pszString,  int cchString,  int dwFlags,  Addressable pbBinary,  Addressable pcbBinary,  Addressable pdwSkip,  Addressable pdwFlags) {
        var mh$ = CryptStringToBinaryW$MH();
        try {
            return (int)mh$.invokeExact(pszString, cchString, dwFlags, pbBinary, pcbBinary, pdwSkip, pdwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptBinaryToStringA$MH() {
        return RuntimeHelper.requireNonNull(constants$629.CryptBinaryToStringA$MH,"CryptBinaryToStringA");
    }
    public static int CryptBinaryToStringA ( Addressable pbBinary,  int cbBinary,  int dwFlags,  Addressable pszString,  Addressable pcchString) {
        var mh$ = CryptBinaryToStringA$MH();
        try {
            return (int)mh$.invokeExact(pbBinary, cbBinary, dwFlags, pszString, pcchString);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptBinaryToStringW$MH() {
        return RuntimeHelper.requireNonNull(constants$629.CryptBinaryToStringW$MH,"CryptBinaryToStringW");
    }
    public static int CryptBinaryToStringW ( Addressable pbBinary,  int cbBinary,  int dwFlags,  Addressable pszString,  Addressable pcchString) {
        var mh$ = CryptBinaryToStringW$MH();
        try {
            return (int)mh$.invokeExact(pbBinary, cbBinary, dwFlags, pszString, pcchString);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle PFXImportCertStore$MH() {
        return RuntimeHelper.requireNonNull(constants$630.PFXImportCertStore$MH,"PFXImportCertStore");
    }
    public static MemoryAddress PFXImportCertStore ( Addressable pPFX,  Addressable szPassword,  int dwFlags) {
        var mh$ = PFXImportCertStore$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle PFXIsPFXBlob$MH() {
        return RuntimeHelper.requireNonNull(constants$630.PFXIsPFXBlob$MH,"PFXIsPFXBlob");
    }
    public static int PFXIsPFXBlob ( Addressable pPFX) {
        var mh$ = PFXIsPFXBlob$MH();
        try {
            return (int)mh$.invokeExact(pPFX);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle PFXVerifyPassword$MH() {
        return RuntimeHelper.requireNonNull(constants$630.PFXVerifyPassword$MH,"PFXVerifyPassword");
    }
    public static int PFXVerifyPassword ( Addressable pPFX,  Addressable szPassword,  int dwFlags) {
        var mh$ = PFXVerifyPassword$MH();
        try {
            return (int)mh$.invokeExact(pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle PFXExportCertStoreEx$MH() {
        return RuntimeHelper.requireNonNull(constants$630.PFXExportCertStoreEx$MH,"PFXExportCertStoreEx");
    }
    public static int PFXExportCertStoreEx ( Addressable hStore,  Addressable pPFX,  Addressable szPassword,  Addressable pvPara,  int dwFlags) {
        var mh$ = PFXExportCertStoreEx$MH();
        try {
            return (int)mh$.invokeExact(hStore, pPFX, szPassword, pvPara, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PPKCS12_PBES2_EXPORT_PARAMS = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle PFXExportCertStore$MH() {
        return RuntimeHelper.requireNonNull(constants$630.PFXExportCertStore$MH,"PFXExportCertStore");
    }
    public static int PFXExportCertStore ( Addressable hStore,  Addressable pPFX,  Addressable szPassword,  int dwFlags) {
        var mh$ = PFXExportCertStore$MH();
        try {
            return (int)mh$.invokeExact(hStore, pPFX, szPassword, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress HCERT_SERVER_OCSP_RESPONSE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SERVER_OCSP_RESPONSE_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_SERVER_OCSP_RESPONSE_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertOpenServerOcspResponse$MH() {
        return RuntimeHelper.requireNonNull(constants$631.CertOpenServerOcspResponse$MH,"CertOpenServerOcspResponse");
    }
    public static MemoryAddress CertOpenServerOcspResponse ( Addressable pChainContext,  int dwFlags,  Addressable pOpenPara) {
        var mh$ = CertOpenServerOcspResponse$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(pChainContext, dwFlags, pOpenPara);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddRefServerOcspResponse$MH() {
        return RuntimeHelper.requireNonNull(constants$631.CertAddRefServerOcspResponse$MH,"CertAddRefServerOcspResponse");
    }
    public static void CertAddRefServerOcspResponse ( Addressable hServerOcspResponse) {
        var mh$ = CertAddRefServerOcspResponse$MH();
        try {
            mh$.invokeExact(hServerOcspResponse);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertCloseServerOcspResponse$MH() {
        return RuntimeHelper.requireNonNull(constants$631.CertCloseServerOcspResponse$MH,"CertCloseServerOcspResponse");
    }
    public static void CertCloseServerOcspResponse ( Addressable hServerOcspResponse,  int dwFlags) {
        var mh$ = CertCloseServerOcspResponse$MH();
        try {
            mh$.invokeExact(hServerOcspResponse, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertGetServerOcspResponseContext$MH() {
        return RuntimeHelper.requireNonNull(constants$631.CertGetServerOcspResponseContext$MH,"CertGetServerOcspResponseContext");
    }
    public static MemoryAddress CertGetServerOcspResponseContext ( Addressable hServerOcspResponse,  int dwFlags,  Addressable pvReserved) {
        var mh$ = CertGetServerOcspResponseContext$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(hServerOcspResponse, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertAddRefServerOcspResponseContext$MH() {
        return RuntimeHelper.requireNonNull(constants$631.CertAddRefServerOcspResponseContext$MH,"CertAddRefServerOcspResponseContext");
    }
    public static void CertAddRefServerOcspResponseContext ( Addressable pServerOcspResponseContext) {
        var mh$ = CertAddRefServerOcspResponseContext$MH();
        try {
            mh$.invokeExact(pServerOcspResponseContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeServerOcspResponseContext$MH() {
        return RuntimeHelper.requireNonNull(constants$632.CertFreeServerOcspResponseContext$MH,"CertFreeServerOcspResponseContext");
    }
    public static void CertFreeServerOcspResponseContext ( Addressable pServerOcspResponseContext) {
        var mh$ = CertFreeServerOcspResponseContext$MH();
        try {
            mh$.invokeExact(pServerOcspResponseContext);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertRetrieveLogoOrBiometricInfo$MH() {
        return RuntimeHelper.requireNonNull(constants$632.CertRetrieveLogoOrBiometricInfo$MH,"CertRetrieveLogoOrBiometricInfo");
    }
    public static int CertRetrieveLogoOrBiometricInfo ( Addressable pCertContext,  Addressable lpszLogoOrBiometricType,  int dwRetrievalFlags,  int dwTimeout,  int dwFlags,  Addressable pvReserved,  Addressable ppbData,  Addressable pcbData,  Addressable ppwszMimeType) {
        var mh$ = CertRetrieveLogoOrBiometricInfo$MH();
        try {
            return (int)mh$.invokeExact(pCertContext, lpszLogoOrBiometricType, dwRetrievalFlags, dwTimeout, dwFlags, pvReserved, ppbData, pcbData, ppwszMimeType);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCERT_SELECT_CHAIN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_SELECT_CHAIN_PARA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCERT_SELECT_CRITERIA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCCERT_SELECT_CRITERIA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertSelectCertificateChains$MH() {
        return RuntimeHelper.requireNonNull(constants$632.CertSelectCertificateChains$MH,"CertSelectCertificateChains");
    }
    public static int CertSelectCertificateChains ( Addressable pSelectionContext,  int dwFlags,  Addressable pChainParameters,  int cCriteria,  Addressable rgpCriteria,  Addressable hStore,  Addressable pcSelection,  Addressable pprgpSelection) {
        var mh$ = CertSelectCertificateChains$MH();
        try {
            return (int)mh$.invokeExact(pSelectionContext, dwFlags, pChainParameters, cCriteria, rgpCriteria, hStore, pcSelection, pprgpSelection);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CertFreeCertificateChainList$MH() {
        return RuntimeHelper.requireNonNull(constants$632.CertFreeCertificateChainList$MH,"CertFreeCertificateChainList");
    }
    public static void CertFreeCertificateChainList ( Addressable prgpSelection) {
        var mh$ = CertFreeCertificateChainList$MH();
        try {
            mh$.invokeExact(prgpSelection);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_TIMESTAMP_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIMESTAMP_RESPONSE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIMESTAMP_ACCURACY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIMESTAMP_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIMESTAMP_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCRYPT_TIMESTAMP_PARA = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptRetrieveTimeStamp$MH() {
        return RuntimeHelper.requireNonNull(constants$632.CryptRetrieveTimeStamp$MH,"CryptRetrieveTimeStamp");
    }
    public static int CryptRetrieveTimeStamp ( Addressable wszUrl,  int dwRetrievalFlags,  int dwTimeout,  Addressable pszHashId,  Addressable pPara,  Addressable pbData,  int cbData,  Addressable ppTsContext,  Addressable ppTsSigner,  Addressable phStore) {
        var mh$ = CryptRetrieveTimeStamp$MH();
        try {
            return (int)mh$.invokeExact(wszUrl, dwRetrievalFlags, dwTimeout, pszHashId, pPara, pbData, cbData, ppTsContext, ppTsSigner, phStore);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptVerifyTimeStampSignature$MH() {
        return RuntimeHelper.requireNonNull(constants$632.CryptVerifyTimeStampSignature$MH,"CryptVerifyTimeStampSignature");
    }
    public static int CryptVerifyTimeStampSignature ( Addressable pbTSContentInfo,  int cbTSContentInfo,  Addressable pbData,  int cbData,  Addressable hAdditionalStore,  Addressable ppTsContext,  Addressable ppTsSigner,  Addressable phStore) {
        var mh$ = CryptVerifyTimeStampSignature$MH();
        try {
            return (int)mh$.invokeExact(pbTSContentInfo, cbTSContentInfo, pbData, cbData, hAdditionalStore, ppTsContext, ppTsSigner, phStore);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CertIsWeakHash$MH() {
        return RuntimeHelper.requireNonNull(constants$635.CertIsWeakHash$MH,"CertIsWeakHash");
    }
    public static int CertIsWeakHash ( int dwHashUseType,  Addressable pwszCNGHashAlgid,  int dwChainFlags,  Addressable pSignerChainContext,  Addressable pTimeStamp,  Addressable pwszFileName) {
        var mh$ = CertIsWeakHash$MH();
        try {
            return (int)mh$.invokeExact(dwHashUseType, pwszCNGHashAlgid, dwChainFlags, pSignerChainContext, pTimeStamp, pwszFileName);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PCRYPTPROTECT_PROMPTSTRUCT = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle CryptProtectData$MH() {
        return RuntimeHelper.requireNonNull(constants$635.CryptProtectData$MH,"CryptProtectData");
    }
    public static int CryptProtectData ( Addressable pDataIn,  Addressable szDataDescr,  Addressable pOptionalEntropy,  Addressable pvReserved,  Addressable pPromptStruct,  int dwFlags,  Addressable pDataOut) {
        var mh$ = CryptProtectData$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnprotectData$MH() {
        return RuntimeHelper.requireNonNull(constants$636.CryptUnprotectData$MH,"CryptUnprotectData");
    }
    public static int CryptUnprotectData ( Addressable pDataIn,  Addressable ppszDataDescr,  Addressable pOptionalEntropy,  Addressable pvReserved,  Addressable pPromptStruct,  int dwFlags,  Addressable pDataOut) {
        var mh$ = CryptUnprotectData$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pDataOut);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptProtectDataNoUI$MH() {
        return RuntimeHelper.requireNonNull(constants$636.CryptProtectDataNoUI$MH,"CryptProtectDataNoUI");
    }
    public static int CryptProtectDataNoUI ( Addressable pDataIn,  Addressable szDataDescr,  Addressable pOptionalEntropy,  Addressable pvReserved,  Addressable pPromptStruct,  int dwFlags,  Addressable pbOptionalPassword,  int cbOptionalPassword,  Addressable pDataOut) {
        var mh$ = CryptProtectDataNoUI$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnprotectDataNoUI$MH() {
        return RuntimeHelper.requireNonNull(constants$636.CryptUnprotectDataNoUI$MH,"CryptUnprotectDataNoUI");
    }
    public static int CryptUnprotectDataNoUI ( Addressable pDataIn,  Addressable ppszDataDescr,  Addressable pOptionalEntropy,  Addressable pvReserved,  Addressable pPromptStruct,  int dwFlags,  Addressable pbOptionalPassword,  int cbOptionalPassword,  Addressable pDataOut) {
        var mh$ = CryptUnprotectDataNoUI$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, ppszDataDescr, pOptionalEntropy, pvReserved, pPromptStruct, dwFlags, pbOptionalPassword, cbOptionalPassword, pDataOut);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUpdateProtectedState$MH() {
        return RuntimeHelper.requireNonNull(constants$636.CryptUpdateProtectedState$MH,"CryptUpdateProtectedState");
    }
    public static int CryptUpdateProtectedState ( Addressable pOldSid,  Addressable pwszOldPassword,  int dwFlags,  Addressable pdwSuccessCount,  Addressable pdwFailureCount) {
        var mh$ = CryptUpdateProtectedState$MH();
        try {
            return (int)mh$.invokeExact(pOldSid, pwszOldPassword, dwFlags, pdwSuccessCount, pdwFailureCount);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptProtectMemory$MH() {
        return RuntimeHelper.requireNonNull(constants$636.CryptProtectMemory$MH,"CryptProtectMemory");
    }
    public static int CryptProtectMemory ( Addressable pDataIn,  int cbDataIn,  int dwFlags) {
        var mh$ = CryptProtectMemory$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, cbDataIn, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle CryptUnprotectMemory$MH() {
        return RuntimeHelper.requireNonNull(constants$636.CryptUnprotectMemory$MH,"CryptUnprotectMemory");
    }
    public static int CryptUnprotectMemory ( Addressable pDataIn,  int cbDataIn,  int dwFlags) {
        var mh$ = CryptUnprotectMemory$MH();
        try {
            return (int)mh$.invokeExact(pDataIn, cbDataIn, dwFlags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PEFS_CERTIFICATE_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_HASH_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_RPC_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_PIN_BLOB = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_KEY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_COMPATIBILITY_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_VERSION_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_DECRYPTION_STATUS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PEFS_ENCRYPTION_STATUS_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_CERTIFICATE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_CERTIFICATE_HASH = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_CERTIFICATE_HASH_LIST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_CERTIFICATE_LIST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTED_FILE_METADATA_SIGNATURE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_PROTECTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PENCRYPTION_PROTECTOR_LIST = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle QueryUsersOnEncryptedFile$MH() {
        return RuntimeHelper.requireNonNull(constants$637.QueryUsersOnEncryptedFile$MH,"QueryUsersOnEncryptedFile");
    }
    public static int QueryUsersOnEncryptedFile ( Addressable lpFileName,  Addressable pUsers) {
        var mh$ = QueryUsersOnEncryptedFile$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pUsers);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle QueryRecoveryAgentsOnEncryptedFile$MH() {
        return RuntimeHelper.requireNonNull(constants$637.QueryRecoveryAgentsOnEncryptedFile$MH,"QueryRecoveryAgentsOnEncryptedFile");
    }
    public static int QueryRecoveryAgentsOnEncryptedFile ( Addressable lpFileName,  Addressable pRecoveryAgents) {
        var mh$ = QueryRecoveryAgentsOnEncryptedFile$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pRecoveryAgents);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle RemoveUsersFromEncryptedFile$MH() {
        return RuntimeHelper.requireNonNull(constants$637.RemoveUsersFromEncryptedFile$MH,"RemoveUsersFromEncryptedFile");
    }
    public static int RemoveUsersFromEncryptedFile ( Addressable lpFileName,  Addressable pHashes) {
        var mh$ = RemoveUsersFromEncryptedFile$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pHashes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle AddUsersToEncryptedFile$MH() {
        return RuntimeHelper.requireNonNull(constants$637.AddUsersToEncryptedFile$MH,"AddUsersToEncryptedFile");
    }
    public static int AddUsersToEncryptedFile ( Addressable lpFileName,  Addressable pEncryptionCertificates) {
        var mh$ = AddUsersToEncryptedFile$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pEncryptionCertificates);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SetUserFileEncryptionKey$MH() {
        return RuntimeHelper.requireNonNull(constants$637.SetUserFileEncryptionKey$MH,"SetUserFileEncryptionKey");
    }
    public static int SetUserFileEncryptionKey ( Addressable pEncryptionCertificate) {
        var mh$ = SetUserFileEncryptionKey$MH();
        try {
            return (int)mh$.invokeExact(pEncryptionCertificate);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SetUserFileEncryptionKeyEx$MH() {
        return RuntimeHelper.requireNonNull(constants$637.SetUserFileEncryptionKeyEx$MH,"SetUserFileEncryptionKeyEx");
    }
    public static int SetUserFileEncryptionKeyEx ( Addressable pEncryptionCertificate,  int dwCapabilities,  int dwFlags,  Addressable pvReserved) {
        var mh$ = SetUserFileEncryptionKeyEx$MH();
        try {
            return (int)mh$.invokeExact(pEncryptionCertificate, dwCapabilities, dwFlags, pvReserved);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle FreeEncryptionCertificateHashList$MH() {
        return RuntimeHelper.requireNonNull(constants$638.FreeEncryptionCertificateHashList$MH,"FreeEncryptionCertificateHashList");
    }
    public static void FreeEncryptionCertificateHashList ( Addressable pUsers) {
        var mh$ = FreeEncryptionCertificateHashList$MH();
        try {
            mh$.invokeExact(pUsers);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle EncryptionDisable$MH() {
        return RuntimeHelper.requireNonNull(constants$638.EncryptionDisable$MH,"EncryptionDisable");
    }
    public static int EncryptionDisable ( Addressable DirPath,  int Disable) {
        var mh$ = EncryptionDisable$MH();
        try {
            return (int)mh$.invokeExact(DirPath, Disable);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DuplicateEncryptionInfoFile$MH() {
        return RuntimeHelper.requireNonNull(constants$638.DuplicateEncryptionInfoFile$MH,"DuplicateEncryptionInfoFile");
    }
    public static int DuplicateEncryptionInfoFile ( Addressable SrcFileName,  Addressable DstFileName,  int dwCreationDistribution,  int dwAttributes,  Addressable lpSecurityAttributes) {
        var mh$ = DuplicateEncryptionInfoFile$MH();
        try {
            return (int)mh$.invokeExact(SrcFileName, DstFileName, dwCreationDistribution, dwAttributes, lpSecurityAttributes);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle GetEncryptedFileMetadata$MH() {
        return RuntimeHelper.requireNonNull(constants$638.GetEncryptedFileMetadata$MH,"GetEncryptedFileMetadata");
    }
    public static int GetEncryptedFileMetadata ( Addressable lpFileName,  Addressable pcbMetadata,  Addressable ppbMetadata) {
        var mh$ = GetEncryptedFileMetadata$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pcbMetadata, ppbMetadata);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle SetEncryptedFileMetadata$MH() {
        return RuntimeHelper.requireNonNull(constants$638.SetEncryptedFileMetadata$MH,"SetEncryptedFileMetadata");
    }
    public static int SetEncryptedFileMetadata ( Addressable lpFileName,  Addressable pbOldMetadata,  Addressable pbNewMetadata,  Addressable pOwnerHash,  int dwOperation,  Addressable pCertificatesAdded) {
        var mh$ = SetEncryptedFileMetadata$MH();
        try {
            return (int)mh$.invokeExact(lpFileName, pbOldMetadata, pbNewMetadata, pOwnerHash, dwOperation, pCertificatesAdded);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle FreeEncryptedFileMetadata$MH() {
        return RuntimeHelper.requireNonNull(constants$638.FreeEncryptedFileMetadata$MH,"FreeEncryptedFileMetadata");
    }
    public static void FreeEncryptedFileMetadata ( Addressable pbMetadata) {
        var mh$ = FreeEncryptedFileMetadata$MH();
        try {
            mh$.invokeExact(pbMetadata);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfShort SHORT = Constants$root.C_SHORT$LAYOUT;
    public static MemorySegment GUID_DEVINTERFACE_DISK$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$639.GUID_DEVINTERFACE_DISK$SEGMENT,"GUID_DEVINTERFACE_DISK");
    }
    public static MemorySegment GUID_DEVINTERFACE_CDROM$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$639.GUID_DEVINTERFACE_CDROM$SEGMENT,"GUID_DEVINTERFACE_CDROM");
    }
    public static MemorySegment GUID_DEVINTERFACE_PARTITION$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$639.GUID_DEVINTERFACE_PARTITION$SEGMENT,"GUID_DEVINTERFACE_PARTITION");
    }
    public static MemorySegment GUID_DEVINTERFACE_TAPE$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$639.GUID_DEVINTERFACE_TAPE$SEGMENT,"GUID_DEVINTERFACE_TAPE");
    }
    public static MemorySegment GUID_DEVINTERFACE_WRITEONCEDISK$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$639.GUID_DEVINTERFACE_WRITEONCEDISK$SEGMENT,"GUID_DEVINTERFACE_WRITEONCEDISK");
    }
    public static MemorySegment GUID_DEVINTERFACE_VOLUME$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$639.GUID_DEVINTERFACE_VOLUME$SEGMENT,"GUID_DEVINTERFACE_VOLUME");
    }
    public static MemorySegment GUID_DEVINTERFACE_MEDIUMCHANGER$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$640.GUID_DEVINTERFACE_MEDIUMCHANGER$SEGMENT,"GUID_DEVINTERFACE_MEDIUMCHANGER");
    }
    public static MemorySegment GUID_DEVINTERFACE_FLOPPY$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$640.GUID_DEVINTERFACE_FLOPPY$SEGMENT,"GUID_DEVINTERFACE_FLOPPY");
    }
    public static MemorySegment GUID_DEVINTERFACE_CDCHANGER$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$640.GUID_DEVINTERFACE_CDCHANGER$SEGMENT,"GUID_DEVINTERFACE_CDCHANGER");
    }
    public static MemorySegment GUID_DEVINTERFACE_STORAGEPORT$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$640.GUID_DEVINTERFACE_STORAGEPORT$SEGMENT,"GUID_DEVINTERFACE_STORAGEPORT");
    }
    public static MemorySegment GUID_DEVINTERFACE_VMLUN$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$640.GUID_DEVINTERFACE_VMLUN$SEGMENT,"GUID_DEVINTERFACE_VMLUN");
    }
    public static MemorySegment GUID_DEVINTERFACE_SES$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$640.GUID_DEVINTERFACE_SES$SEGMENT,"GUID_DEVINTERFACE_SES");
    }
    public static MemorySegment GUID_DEVINTERFACE_SERVICE_VOLUME$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$641.GUID_DEVINTERFACE_SERVICE_VOLUME$SEGMENT,"GUID_DEVINTERFACE_SERVICE_VOLUME");
    }
    public static MemorySegment GUID_DEVINTERFACE_HIDDEN_VOLUME$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$641.GUID_DEVINTERFACE_HIDDEN_VOLUME$SEGMENT,"GUID_DEVINTERFACE_HIDDEN_VOLUME");
    }
    public static MemorySegment GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$641.GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB$SEGMENT,"GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB");
    }
    public static MemorySegment GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$641.GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE$SEGMENT,"GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE");
    }
    public static MemorySegment GUID_SCM_PD_HEALTH_NOTIFICATION$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$641.GUID_SCM_PD_HEALTH_NOTIFICATION$SEGMENT,"GUID_SCM_PD_HEALTH_NOTIFICATION");
    }
    public static MemorySegment GUID_SCM_PD_PASSTHROUGH_INVDIMM$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$641.GUID_SCM_PD_PASSTHROUGH_INVDIMM$SEGMENT,"GUID_SCM_PD_PASSTHROUGH_INVDIMM");
    }
    public static MemorySegment GUID_DEVINTERFACE_COMPORT$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$642.GUID_DEVINTERFACE_COMPORT$SEGMENT,"GUID_DEVINTERFACE_COMPORT");
    }
    public static MemorySegment GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR$SEGMENT() {
        return RuntimeHelper.requireNonNull(constants$642.GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR$SEGMENT,"GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR");
    }
    public static OfAddress PSTORAGE_HOTPLUG_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_NUMBER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_NUMBERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_NUMBER_EX = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_BUS_RESET_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_BREAK_RESERVATION_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PPREVENT_MEDIA_REMOVAL = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PCLASS_MEDIA_CHANGE_CONTEXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PTAPE_STATISTICS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PTAPE_GET_STATISTICS = Constants$root.C_POINTER$LAYOUT;
    public static int DDS_4mm() {
        return (int)32L;
    }
    public static int MiniQic() {
        return (int)33L;
    }
    public static int Travan() {
        return (int)34L;
    }
    public static int QIC() {
        return (int)35L;
    }
    public static int MP_8mm() {
        return (int)36L;
    }
    public static int AME_8mm() {
        return (int)37L;
    }
    public static int AIT1_8mm() {
        return (int)38L;
    }
    public static int DLT() {
        return (int)39L;
    }
    public static int NCTP() {
        return (int)40L;
    }
    public static int IBM_3480() {
        return (int)41L;
    }
    public static int IBM_3490E() {
        return (int)42L;
    }
    public static int IBM_Magstar_3590() {
        return (int)43L;
    }
    public static int IBM_Magstar_MP() {
        return (int)44L;
    }
    public static int STK_DATA_D3() {
        return (int)45L;
    }
    public static int SONY_DTF() {
        return (int)46L;
    }
    public static int DV_6mm() {
        return (int)47L;
    }
    public static int DMI() {
        return (int)48L;
    }
    public static int SONY_D2() {
        return (int)49L;
    }
    public static int CLEANER_CARTRIDGE() {
        return (int)50L;
    }
    public static int CD_ROM() {
        return (int)51L;
    }
    public static int CD_R() {
        return (int)52L;
    }
    public static int CD_RW() {
        return (int)53L;
    }
    public static int DVD_ROM() {
        return (int)54L;
    }
    public static int DVD_R() {
        return (int)55L;
    }
    public static int DVD_RW() {
        return (int)56L;
    }
    public static int MO_3_RW() {
        return (int)57L;
    }
    public static int MO_5_WO() {
        return (int)58L;
    }
    public static int MO_5_RW() {
        return (int)59L;
    }
    public static int MO_5_LIMDOW() {
        return (int)60L;
    }
    public static int PC_5_WO() {
        return (int)61L;
    }
    public static int PC_5_RW() {
        return (int)62L;
    }
    public static int PD_5_RW() {
        return (int)63L;
    }
    public static int ABL_5_WO() {
        return (int)64L;
    }
    public static int PINNACLE_APEX_5_RW() {
        return (int)65L;
    }
    public static int SONY_12_WO() {
        return (int)66L;
    }
    public static int PHILIPS_12_WO() {
        return (int)67L;
    }
    public static int HITACHI_12_WO() {
        return (int)68L;
    }
    public static int CYGNET_12_WO() {
        return (int)69L;
    }
    public static int KODAK_14_WO() {
        return (int)70L;
    }
    public static int MO_NFR_525() {
        return (int)71L;
    }
    public static int NIKON_12_RW() {
        return (int)72L;
    }
    public static int IOMEGA_ZIP() {
        return (int)73L;
    }
    public static int IOMEGA_JAZ() {
        return (int)74L;
    }
    public static int SYQUEST_EZ135() {
        return (int)75L;
    }
    public static int SYQUEST_EZFLYER() {
        return (int)76L;
    }
    public static int SYQUEST_SYJET() {
        return (int)77L;
    }
    public static int AVATAR_F2() {
        return (int)78L;
    }
    public static int MP2_8mm() {
        return (int)79L;
    }
    public static int DST_S() {
        return (int)80L;
    }
    public static int DST_M() {
        return (int)81L;
    }
    public static int DST_L() {
        return (int)82L;
    }
    public static int VXATape_1() {
        return (int)83L;
    }
    public static int VXATape_2() {
        return (int)84L;
    }
    public static int STK_9840() {
        return (int)85L;
    }
    public static int LTO_Ultrium() {
        return (int)86L;
    }
    public static int LTO_Accelis() {
        return (int)87L;
    }
    public static int DVD_RAM() {
        return (int)88L;
    }
    public static int AIT_8mm() {
        return (int)89L;
    }
    public static int ADR_1() {
        return (int)90L;
    }
    public static int ADR_2() {
        return (int)91L;
    }
    public static int STK_9940() {
        return (int)92L;
    }
    public static int SAIT() {
        return (int)93L;
    }
    public static int VXATape() {
        return (int)94L;
    }
    public static OfAddress PSTORAGE_MEDIA_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static int BusTypeUnknown() {
        return (int)0L;
    }
    public static int BusTypeScsi() {
        return (int)1L;
    }
    public static int BusTypeAtapi() {
        return (int)2L;
    }
    public static int BusTypeAta() {
        return (int)3L;
    }
    public static int BusType1394() {
        return (int)4L;
    }
    public static int BusTypeSsa() {
        return (int)5L;
    }
    public static int BusTypeFibre() {
        return (int)6L;
    }
    public static int BusTypeUsb() {
        return (int)7L;
    }
    public static int BusTypeRAID() {
        return (int)8L;
    }
    public static int BusTypeiScsi() {
        return (int)9L;
    }
    public static int BusTypeSas() {
        return (int)10L;
    }
    public static int BusTypeSata() {
        return (int)11L;
    }
    public static int BusTypeSd() {
        return (int)12L;
    }
    public static int BusTypeMmc() {
        return (int)13L;
    }
    public static int BusTypeVirtual() {
        return (int)14L;
    }
    public static int BusTypeFileBackedVirtual() {
        return (int)15L;
    }
    public static int BusTypeSpaces() {
        return (int)16L;
    }
    public static int BusTypeNvme() {
        return (int)17L;
    }
    public static int BusTypeSCM() {
        return (int)18L;
    }
    public static int BusTypeUfs() {
        return (int)19L;
    }
    public static int BusTypeMax() {
        return (int)20L;
    }
    public static int BusTypeMaxReserved() {
        return (int)127L;
    }
    public static OfAddress PSTORAGE_BUS_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_MEDIA_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PGET_MEDIA_TYPES = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PREDICT_FAILURE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_FAILURE_PREDICTION_CONFIG = Constants$root.C_POINTER$LAYOUT;
    public static int PropertyStandardQuery() {
        return (int)0L;
    }
    public static int PropertyExistsQuery() {
        return (int)1L;
    }
    public static int PropertyMaskQuery() {
        return (int)2L;
    }
    public static int PropertyQueryMaxDefined() {
        return (int)3L;
    }
    public static OfAddress PSTORAGE_QUERY_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static int PropertyStandardSet() {
        return (int)0L;
    }
    public static int PropertyExistsSet() {
        return (int)1L;
    }
    public static int PropertySetMaxDefined() {
        return (int)2L;
    }
    public static OfAddress PSTORAGE_SET_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static int StorageDeviceProperty() {
        return (int)0L;
    }
    public static int StorageAdapterProperty() {
        return (int)1L;
    }
    public static int StorageDeviceIdProperty() {
        return (int)2L;
    }
    public static int StorageDeviceUniqueIdProperty() {
        return (int)3L;
    }
    public static int StorageDeviceWriteCacheProperty() {
        return (int)4L;
    }
    public static int StorageMiniportProperty() {
        return (int)5L;
    }
    public static int StorageAccessAlignmentProperty() {
        return (int)6L;
    }
    public static int StorageDeviceSeekPenaltyProperty() {
        return (int)7L;
    }
    public static int StorageDeviceTrimProperty() {
        return (int)8L;
    }
    public static int StorageDeviceWriteAggregationProperty() {
        return (int)9L;
    }
    public static int StorageDeviceDeviceTelemetryProperty() {
        return (int)10L;
    }
    public static int StorageDeviceLBProvisioningProperty() {
        return (int)11L;
    }
    public static int StorageDevicePowerProperty() {
        return (int)12L;
    }
    public static int StorageDeviceCopyOffloadProperty() {
        return (int)13L;
    }
    public static int StorageDeviceResiliencyProperty() {
        return (int)14L;
    }
    public static int StorageDeviceMediumProductType() {
        return (int)15L;
    }
    public static int StorageAdapterRpmbProperty() {
        return (int)16L;
    }
    public static int StorageAdapterCryptoProperty() {
        return (int)17L;
    }
    public static int StorageDeviceIoCapabilityProperty() {
        return (int)48L;
    }
    public static int StorageAdapterProtocolSpecificProperty() {
        return (int)49L;
    }
    public static int StorageDeviceProtocolSpecificProperty() {
        return (int)50L;
    }
    public static int StorageAdapterTemperatureProperty() {
        return (int)51L;
    }
    public static int StorageDeviceTemperatureProperty() {
        return (int)52L;
    }
    public static int StorageAdapterPhysicalTopologyProperty() {
        return (int)53L;
    }
    public static int StorageDevicePhysicalTopologyProperty() {
        return (int)54L;
    }
    public static int StorageDeviceAttributesProperty() {
        return (int)55L;
    }
    public static int StorageDeviceManagementStatus() {
        return (int)56L;
    }
    public static int StorageAdapterSerialNumberProperty() {
        return (int)57L;
    }
    public static int StorageDeviceLocationProperty() {
        return (int)58L;
    }
    public static int StorageDeviceNumaProperty() {
        return (int)59L;
    }
    public static int StorageDeviceZonedDeviceProperty() {
        return (int)60L;
    }
    public static int StorageDeviceUnsafeShutdownCount() {
        return (int)61L;
    }
    public static int StorageDeviceEnduranceProperty() {
        return (int)62L;
    }
    public static OfAddress PSTORAGE_PROPERTY_ID = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PROPERTY_QUERY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PROPERTY_SET = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DESCRIPTOR_HEADER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_ADAPTER_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static int StoragePortCodeSetReserved() {
        return (int)0L;
    }
    public static int StoragePortCodeSetStorport() {
        return (int)1L;
    }
    public static int StoragePortCodeSetSCSIport() {
        return (int)2L;
    }
    public static int StoragePortCodeSetSpaceport() {
        return (int)3L;
    }
    public static int StoragePortCodeSetATAport() {
        return (int)4L;
    }
    public static int StoragePortCodeSetUSBport() {
        return (int)5L;
    }
    public static int StoragePortCodeSetSBP2port() {
        return (int)6L;
    }
    public static int StoragePortCodeSetSDport() {
        return (int)7L;
    }
    public static OfAddress PSTORAGE_PORT_CODE_SET = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_MINIPORT_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static int StorageIdCodeSetReserved() {
        return (int)0L;
    }
    public static int StorageIdCodeSetBinary() {
        return (int)1L;
    }
    public static int StorageIdCodeSetAscii() {
        return (int)2L;
    }
    public static int StorageIdCodeSetUtf8() {
        return (int)3L;
    }
    public static OfAddress PSTORAGE_IDENTIFIER_CODE_SET = Constants$root.C_POINTER$LAYOUT;
    public static int StorageIdTypeVendorSpecific() {
        return (int)0L;
    }
    public static int StorageIdTypeVendorId() {
        return (int)1L;
    }
    public static int StorageIdTypeEUI64() {
        return (int)2L;
    }
    public static int StorageIdTypeFCPHName() {
        return (int)3L;
    }
    public static int StorageIdTypePortRelative() {
        return (int)4L;
    }
    public static int StorageIdTypeTargetPortGroup() {
        return (int)5L;
    }
    public static int StorageIdTypeLogicalUnitGroup() {
        return (int)6L;
    }
    public static int StorageIdTypeMD5LogicalUnitIdentifier() {
        return (int)7L;
    }
    public static int StorageIdTypeScsiNameString() {
        return (int)8L;
    }
    public static OfAddress PSTORAGE_IDENTIFIER_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static int StorageIdNAAFormatIEEEExtended() {
        return (int)2L;
    }
    public static int StorageIdNAAFormatIEEERegistered() {
        return (int)3L;
    }
    public static int StorageIdNAAFormatIEEEERegisteredExtended() {
        return (int)5L;
    }
    public static OfAddress PSTORAGE_ID_NAA_FORMAT = Constants$root.C_POINTER$LAYOUT;
    public static int StorageIdAssocDevice() {
        return (int)0L;
    }
    public static int StorageIdAssocPort() {
        return (int)1L;
    }
    public static int StorageIdAssocTarget() {
        return (int)2L;
    }
    public static OfAddress PSTORAGE_ASSOCIATION_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_IDENTIFIER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_ID_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_SEEK_PENALTY_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_WRITE_AGGREGATION_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_TRIM_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_LB_PROVISIONING_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_LB_PROVISIONING_MAP_RESOURCES = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_POWER_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_COPY_OFFLOAD_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_RESILIENCY_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static int StorageRpmbFrameTypeUnknown() {
        return (int)0L;
    }
    public static int StorageRpmbFrameTypeStandard() {
        return (int)1L;
    }
    public static int StorageRpmbFrameTypeMax() {
        return (int)2L;
    }
    public static OfAddress PSTORAGE_RPMB_FRAME_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_RPMB_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static int StorageCryptoAlgorithmUnknown() {
        return (int)0L;
    }
    public static int StorageCryptoAlgorithmXTSAES() {
        return (int)1L;
    }
    public static int StorageCryptoAlgorithmBitlockerAESCBC() {
        return (int)2L;
    }
    public static int StorageCryptoAlgorithmAESECB() {
        return (int)3L;
    }
    public static int StorageCryptoAlgorithmESSIVAESCBC() {
        return (int)4L;
    }
    public static int StorageCryptoAlgorithmMax() {
        return (int)5L;
    }
    public static OfAddress PSTORAGE_CRYPTO_ALGORITHM_ID = Constants$root.C_POINTER$LAYOUT;
    public static int StorageCryptoKeySizeUnknown() {
        return (int)0L;
    }
    public static int StorageCryptoKeySize128Bits() {
        return (int)1L;
    }
    public static int StorageCryptoKeySize192Bits() {
        return (int)2L;
    }
    public static int StorageCryptoKeySize256Bits() {
        return (int)3L;
    }
    public static int StorageCryptoKeySize512Bits() {
        return (int)4L;
    }
    public static OfAddress PSTORAGE_CRYPTO_KEY_SIZE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_CRYPTO_CAPABILITY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_CRYPTO_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static int StorageTierMediaTypeUnspecified() {
        return (int)0L;
    }
    public static int StorageTierMediaTypeDisk() {
        return (int)1L;
    }
    public static int StorageTierMediaTypeSsd() {
        return (int)2L;
    }
    public static int StorageTierMediaTypeScm() {
        return (int)4L;
    }
    public static int StorageTierMediaTypeMax() {
        return (int)5L;
    }
    public static OfAddress PSTORAGE_TIER_MEDIA_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static int StorageTierClassUnspecified() {
        return (int)0L;
    }
    public static int StorageTierClassCapacity() {
        return (int)1L;
    }
    public static int StorageTierClassPerformance() {
        return (int)2L;
    }
    public static int StorageTierClassMax() {
        return (int)3L;
    }
    public static OfAddress PSTORAGE_TIER_CLASS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_TIER = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_TIERING_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static int ProtocolTypeUnknown() {
        return (int)0L;
    }
    public static int ProtocolTypeScsi() {
        return (int)1L;
    }
    public static int ProtocolTypeAta() {
        return (int)2L;
    }
    public static int ProtocolTypeNvme() {
        return (int)3L;
    }
    public static int ProtocolTypeSd() {
        return (int)4L;
    }
    public static int ProtocolTypeUfs() {
        return (int)5L;
    }
    public static int ProtocolTypeProprietary() {
        return (int)126L;
    }
    public static int ProtocolTypeMaxReserved() {
        return (int)127L;
    }
    public static OfAddress PSTORAGE_PROTOCOL_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static int NVMeDataTypeUnknown() {
        return (int)0L;
    }
    public static int NVMeDataTypeIdentify() {
        return (int)1L;
    }
    public static int NVMeDataTypeLogPage() {
        return (int)2L;
    }
    public static int NVMeDataTypeFeature() {
        return (int)3L;
    }
    public static OfAddress PSTORAGE_PROTOCOL_NVME_DATA_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static int AtaDataTypeUnknown() {
        return (int)0L;
    }
    public static int AtaDataTypeIdentify() {
        return (int)1L;
    }
    public static int AtaDataTypeLogPage() {
        return (int)2L;
    }
    public static OfAddress PSTORAGE_PROTOCOL_ATA_DATA_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static int UfsDataTypeUnknown() {
        return (int)0L;
    }
    public static int UfsDataTypeQueryDescriptor() {
        return (int)1L;
    }
    public static int UfsDataTypeMax() {
        return (int)2L;
    }
    public static OfAddress PSTORAGE_PROTOCOL_UFS_DATA_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PROTOCOL_SPECIFIC_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PROTOCOL_SPECIFIC_DATA_EXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PROTOCOL_DATA_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_TEMPERATURE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_TEMPERATURE_DATA_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_TEMPERATURE_THRESHOLD = Constants$root.C_POINTER$LAYOUT;
    public static int FormFactorUnknown() {
        return (int)0L;
    }
    public static int FormFactor3_5() {
        return (int)1L;
    }
    public static int FormFactor2_5() {
        return (int)2L;
    }
    public static int FormFactor1_8() {
        return (int)3L;
    }
    public static int FormFactor1_8Less() {
        return (int)4L;
    }
    public static int FormFactorEmbedded() {
        return (int)5L;
    }
    public static int FormFactorMemoryCard() {
        return (int)6L;
    }
    public static int FormFactormSata() {
        return (int)7L;
    }
    public static int FormFactorM_2() {
        return (int)8L;
    }
    public static int FormFactorPCIeBoard() {
        return (int)9L;
    }
    public static int FormFactorDimm() {
        return (int)10L;
    }
    public static OfAddress PSTORAGE_DEVICE_FORM_FACTOR = Constants$root.C_POINTER$LAYOUT;
    public static int HealthStatusUnknown() {
        return (int)0L;
    }
    public static int HealthStatusNormal() {
        return (int)1L;
    }
    public static int HealthStatusThrottled() {
        return (int)2L;
    }
    public static int HealthStatusWarning() {
        return (int)3L;
    }
    public static int HealthStatusDisabled() {
        return (int)4L;
    }
    public static int HealthStatusFailed() {
        return (int)5L;
    }
    public static OfAddress PSTORAGE_COMPONENT_HEALTH_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_SPEC_VERSION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PHYSICAL_DEVICE_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PHYSICAL_ADAPTER_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PHYSICAL_NODE_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static int DiskHealthUnknown() {
        return (int)0L;
    }
    public static int DiskHealthUnhealthy() {
        return (int)1L;
    }
    public static int DiskHealthWarning() {
        return (int)2L;
    }
    public static int DiskHealthHealthy() {
        return (int)3L;
    }
    public static int DiskHealthMax() {
        return (int)4L;
    }
    public static OfAddress PSTORAGE_DISK_HEALTH_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static int DiskOpStatusNone() {
        return (int)0L;
    }
    public static int DiskOpStatusUnknown() {
        return (int)1L;
    }
    public static int DiskOpStatusOk() {
        return (int)2L;
    }
    public static int DiskOpStatusPredictingFailure() {
        return (int)3L;
    }
    public static int DiskOpStatusInService() {
        return (int)4L;
    }
    public static int DiskOpStatusHardwareError() {
        return (int)5L;
    }
    public static int DiskOpStatusNotUsable() {
        return (int)6L;
    }
    public static int DiskOpStatusTransientError() {
        return (int)7L;
    }
    public static int DiskOpStatusMissing() {
        return (int)8L;
    }
    public static OfAddress PSTORAGE_DISK_OPERATIONAL_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static int DiskOpReasonUnknown() {
        return (int)0L;
    }
    public static int DiskOpReasonScsiSenseCode() {
        return (int)1L;
    }
    public static int DiskOpReasonMedia() {
        return (int)2L;
    }
    public static int DiskOpReasonIo() {
        return (int)3L;
    }
    public static int DiskOpReasonThresholdExceeded() {
        return (int)4L;
    }
    public static int DiskOpReasonLostData() {
        return (int)5L;
    }
    public static int DiskOpReasonEnergySource() {
        return (int)6L;
    }
    public static int DiskOpReasonConfiguration() {
        return (int)7L;
    }
    public static int DiskOpReasonDeviceController() {
        return (int)8L;
    }
    public static int DiskOpReasonMediaController() {
        return (int)9L;
    }
    public static int DiskOpReasonComponent() {
        return (int)10L;
    }
    public static int DiskOpReasonNVDIMM_N() {
        return (int)11L;
    }
    public static int DiskOpReasonBackgroundOperation() {
        return (int)12L;
    }
    public static int DiskOpReasonInvalidFirmware() {
        return (int)13L;
    }
    public static int DiskOpReasonHealthCheck() {
        return (int)14L;
    }
    public static int DiskOpReasonLostDataPersistence() {
        return (int)15L;
    }
    public static int DiskOpReasonDisabledByPlatform() {
        return (int)16L;
    }
    public static int DiskOpReasonLostWritePersistence() {
        return (int)17L;
    }
    public static int DiskOpReasonDataPersistenceLossImminent() {
        return (int)18L;
    }
    public static int DiskOpReasonWritePersistenceLossImminent() {
        return (int)19L;
    }
    public static int DiskOpReasonMax() {
        return (int)20L;
    }
    public static OfAddress PSTORAGE_OPERATIONAL_STATUS_REASON = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_OPERATIONAL_REASON = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_MANAGEMENT_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_ADAPTER_SERIAL_NUMBER = Constants$root.C_POINTER$LAYOUT;
    public static int ZonedDeviceTypeUnknown() {
        return (int)0L;
    }
    public static int ZonedDeviceTypeHostManaged() {
        return (int)1L;
    }
    public static int ZonedDeviceTypeHostAware() {
        return (int)2L;
    }
    public static int ZonedDeviceTypeDeviceManaged() {
        return (int)3L;
    }
    public static OfAddress PSTORAGE_ZONED_DEVICE_TYPES = Constants$root.C_POINTER$LAYOUT;
    public static int ZoneTypeUnknown() {
        return (int)0L;
    }
    public static int ZoneTypeConventional() {
        return (int)1L;
    }
    public static int ZoneTypeSequentialWriteRequired() {
        return (int)2L;
    }
    public static int ZoneTypeSequentialWritePreferred() {
        return (int)3L;
    }
    public static int ZoneTypeMax() {
        return (int)4L;
    }
    public static OfAddress PSTORAGE_ZONE_TYPES = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_ZONE_GROUP = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_ZONED_DEVICE_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_LOCATION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_LOCATION_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_NUMA_PROPERTY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_HW_ENDURANCE_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DATA_SET_RANGE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_RANGE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_MANAGE_DATA_SET_ATTRIBUTES = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_INPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_DEFINITION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_NOTIFICATION_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_OFFLOAD_TOKEN = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_OFFLOAD_READ_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_OFFLOAD_READ_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_OFFLOAD_WRITE_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DATA_SET_LBP_STATE_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_ALLOCATION_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DATA_SET_LB_PROVISIONING_STATE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_ALLOCATION_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_ALLOCATION_OUTPUT2 = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DATA_SET_REPAIR_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_REPAIR_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DATA_SET_REPAIR_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_REPAIR_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DATA_SET_SCRUB_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_SCRUB_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DATA_SET_SCRUB_EX_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_SCRUB_OUTPUT2 = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_TIERING_QUERY_INPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_TIERING_QUERY_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_TIER_REGION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_TIERING_QUERY_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_STORAGE_ADDRESS_RANGE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_REPORT_ZONES_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static int ZonesAttributeTypeAndLengthMayDifferent() {
        return (int)0L;
    }
    public static int ZonesAttributeTypeSameLengthSame() {
        return (int)1L;
    }
    public static int ZonesAttributeTypeSameLastZoneLengthDifferent() {
        return (int)2L;
    }
    public static int ZonesAttributeTypeMayDifferentLengthSame() {
        return (int)3L;
    }
    public static OfAddress PSTORAGE_ZONES_ATTRIBUTES = Constants$root.C_POINTER$LAYOUT;
    public static int ZoneConditionConventional() {
        return (int)0L;
    }
    public static int ZoneConditionEmpty() {
        return (int)1L;
    }
    public static int ZoneConditionImplicitlyOpened() {
        return (int)2L;
    }
    public static int ZoneConditionExplicitlyOpened() {
        return (int)3L;
    }
    public static int ZoneConditionClosed() {
        return (int)4L;
    }
    public static int ZoneConditionReadOnly() {
        return (int)13L;
    }
    public static int ZoneConditionFull() {
        return (int)14L;
    }
    public static int ZoneConditionOffline() {
        return (int)15L;
    }
    public static OfAddress PSTORAGE_ZONE_CONDITION = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_ZONE_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_REPORT_ZONES_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_REPORT_ZONES_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_STORAGE_RANGE_ATTRIBUTES = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_RANGE_ERROR_INFO = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_RANGE_ERROR_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_LOST_QUERY_PARAMETERS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_LOST_QUERY_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_FREE_SPACE_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_DSM_CONVERSION_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static MethodHandle DeviceDsmParameterBlock$MH() {
        return RuntimeHelper.requireNonNull(constants$642.DeviceDsmParameterBlock$MH,"DeviceDsmParameterBlock");
    }
    public static MemoryAddress DeviceDsmParameterBlock ( Addressable Input) {
        var mh$ = DeviceDsmParameterBlock$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(Input);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmDataSetRanges$MH() {
        return RuntimeHelper.requireNonNull(constants$642.DeviceDsmDataSetRanges$MH,"DeviceDsmDataSetRanges");
    }
    public static MemoryAddress DeviceDsmDataSetRanges ( Addressable Input) {
        var mh$ = DeviceDsmDataSetRanges$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(Input);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmNumberOfDataSetRanges$MH() {
        return RuntimeHelper.requireNonNull(constants$642.DeviceDsmNumberOfDataSetRanges$MH,"DeviceDsmNumberOfDataSetRanges");
    }
    public static int DeviceDsmNumberOfDataSetRanges ( Addressable Input) {
        var mh$ = DeviceDsmNumberOfDataSetRanges$MH();
        try {
            return (int)mh$.invokeExact(Input);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmGetInputLength$MH() {
        return RuntimeHelper.requireNonNull(constants$642.DeviceDsmGetInputLength$MH,"DeviceDsmGetInputLength");
    }
    public static int DeviceDsmGetInputLength ( Addressable Definition,  int ParameterBlockLength,  int NumberOfDataSetRanges) {
        var mh$ = DeviceDsmGetInputLength$MH();
        try {
            return (int)mh$.invokeExact(Definition, ParameterBlockLength, NumberOfDataSetRanges);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmGetNumberOfDataSetRanges$MH() {
        return RuntimeHelper.requireNonNull(constants$643.DeviceDsmGetNumberOfDataSetRanges$MH,"DeviceDsmGetNumberOfDataSetRanges");
    }
    public static int DeviceDsmGetNumberOfDataSetRanges ( Addressable Definition,  int InputLength,  int ParameterBlockLength) {
        var mh$ = DeviceDsmGetNumberOfDataSetRanges$MH();
        try {
            return (int)mh$.invokeExact(Definition, InputLength, ParameterBlockLength);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmInitializeInput$MH() {
        return RuntimeHelper.requireNonNull(constants$643.DeviceDsmInitializeInput$MH,"DeviceDsmInitializeInput");
    }
    public static void DeviceDsmInitializeInput ( Addressable Definition,  Addressable Input,  int InputLength,  int Flags,  Addressable Parameters,  int ParameterBlockLength) {
        var mh$ = DeviceDsmInitializeInput$MH();
        try {
            mh$.invokeExact(Definition, Input, InputLength, Flags, Parameters, ParameterBlockLength);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmAddDataSetRange$MH() {
        return RuntimeHelper.requireNonNull(constants$643.DeviceDsmAddDataSetRange$MH,"DeviceDsmAddDataSetRange");
    }
    public static byte DeviceDsmAddDataSetRange ( Addressable Input,  int InputLength,  long Offset,  long Length) {
        var mh$ = DeviceDsmAddDataSetRange$MH();
        try {
            return (byte)mh$.invokeExact(Input, InputLength, Offset, Length);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmValidateInput$MH() {
        return RuntimeHelper.requireNonNull(constants$643.DeviceDsmValidateInput$MH,"DeviceDsmValidateInput");
    }
    public static byte DeviceDsmValidateInput ( Addressable Definition,  Addressable Input,  int InputLength) {
        var mh$ = DeviceDsmValidateInput$MH();
        try {
            return (byte)mh$.invokeExact(Definition, Input, InputLength);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmOutputBlock$MH() {
        return RuntimeHelper.requireNonNull(constants$643.DeviceDsmOutputBlock$MH,"DeviceDsmOutputBlock");
    }
    public static MemoryAddress DeviceDsmOutputBlock ( Addressable Output) {
        var mh$ = DeviceDsmOutputBlock$MH();
        try {
            return (java.lang.foreign.MemoryAddress)mh$.invokeExact(Output);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmGetOutputLength$MH() {
        return RuntimeHelper.requireNonNull(constants$643.DeviceDsmGetOutputLength$MH,"DeviceDsmGetOutputLength");
    }
    public static int DeviceDsmGetOutputLength ( Addressable Definition,  int OutputBlockLength) {
        var mh$ = DeviceDsmGetOutputLength$MH();
        try {
            return (int)mh$.invokeExact(Definition, OutputBlockLength);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmValidateOutputLength$MH() {
        return RuntimeHelper.requireNonNull(constants$644.DeviceDsmValidateOutputLength$MH,"DeviceDsmValidateOutputLength");
    }
    public static byte DeviceDsmValidateOutputLength ( Addressable Definition,  int OutputLength) {
        var mh$ = DeviceDsmValidateOutputLength$MH();
        try {
            return (byte)mh$.invokeExact(Definition, OutputLength);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmGetOutputBlockLength$MH() {
        return RuntimeHelper.requireNonNull(constants$644.DeviceDsmGetOutputBlockLength$MH,"DeviceDsmGetOutputBlockLength");
    }
    public static int DeviceDsmGetOutputBlockLength ( Addressable Definition,  int OutputLength) {
        var mh$ = DeviceDsmGetOutputBlockLength$MH();
        try {
            return (int)mh$.invokeExact(Definition, OutputLength);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmInitializeOutput$MH() {
        return RuntimeHelper.requireNonNull(constants$644.DeviceDsmInitializeOutput$MH,"DeviceDsmInitializeOutput");
    }
    public static void DeviceDsmInitializeOutput ( Addressable Definition,  Addressable Output,  int OutputLength,  int Flags) {
        var mh$ = DeviceDsmInitializeOutput$MH();
        try {
            mh$.invokeExact(Definition, Output, OutputLength, Flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static MethodHandle DeviceDsmValidateOutput$MH() {
        return RuntimeHelper.requireNonNull(constants$644.DeviceDsmValidateOutput$MH,"DeviceDsmValidateOutput");
    }
    public static byte DeviceDsmValidateOutput ( Addressable Definition,  Addressable Output,  int OutputLength) {
        var mh$ = DeviceDsmValidateOutput$MH();
        try {
            return (byte)mh$.invokeExact(Definition, Output, OutputLength);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
    public static OfAddress PSTORAGE_GET_BC_PROPERTIES_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_ALLOCATE_BC_STREAM_INPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_ALLOCATE_BC_STREAM_OUTPUT = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_PRIORITY_HINT_SUPPORT = Constants$root.C_POINTER$LAYOUT;
    public static int StorageDiagnosticLevelDefault() {
        return (int)0L;
    }
    public static int StorageDiagnosticLevelMax() {
        return (int)1L;
    }
    public static OfAddress PSTORAGE_DIAGNOSTIC_LEVEL = Constants$root.C_POINTER$LAYOUT;
    public static int StorageDiagnosticTargetTypeUndefined() {
        return (int)0L;
    }
    public static int StorageDiagnosticTargetTypePort() {
        return (int)1L;
    }
    public static int StorageDiagnosticTargetTypeMiniport() {
        return (int)2L;
    }
    public static int StorageDiagnosticTargetTypeHbaFirmware() {
        return (int)3L;
    }
    public static int StorageDiagnosticTargetTypeMax() {
        return (int)4L;
    }
    public static OfAddress PSTORAGE_DIAGNOSTIC_TARGET_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DIAGNOSTIC_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_DIAGNOSTIC_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PPHYSICAL_ELEMENT_STATUS_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PPHYSICAL_ELEMENT_STATUS_DESCRIPTOR = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PPHYSICAL_ELEMENT_STATUS = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PREMOVE_ELEMENT_AND_TRUNCATE_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static int DeviceInternalStatusDataRequestTypeUndefined() {
        return (int)0L;
    }
    public static int DeviceCurrentInternalStatusDataHeader() {
        return (int)1L;
    }
    public static int DeviceCurrentInternalStatusData() {
        return (int)2L;
    }
    public static OfAddress PDEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE = Constants$root.C_POINTER$LAYOUT;
    public static int DeviceStatusDataSetUndefined() {
        return (int)0L;
    }
    public static int DeviceStatusDataSet1() {
        return (int)1L;
    }
    public static int DeviceStatusDataSet2() {
        return (int)2L;
    }
    public static int DeviceStatusDataSet3() {
        return (int)3L;
    }
    public static int DeviceStatusDataSet4() {
        return (int)4L;
    }
    public static int DeviceStatusDataSetMax() {
        return (int)5L;
    }
    public static OfAddress PDEVICE_INTERNAL_STATUS_DATA_SET = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PGET_DEVICE_INTERNAL_STATUS_DATA_REQUEST = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PDEVICE_INTERNAL_STATUS_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_MEDIA_SERIAL_NUMBER_DATA = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PSTORAGE_READ_CAPACITY = Constants$root.C_POINTER$LAYOUT;
    public static int WriteCacheTypeUnknown() {
        return (int)0L;
    }
    public static int WriteCacheTypeNone() {
        return (int)1L;
    }
    public static int WriteCacheTypeWriteBack() {
        return (int)2L;
    }
    public static int WriteCacheTypeWriteThrough() {
        return (int)3L;
    }
    public static int WriteCacheEnableUnknown() {
        return (int)0L;
    }
    public static int WriteCacheDisabled() {
        return (int)1L;
    }
    public static int WriteCacheEnabled() {
        return (int)2L;
    }
    public static int WriteCacheChangeUnknown() {
        return (int)0L;
    }
    public static int WriteCacheNotChangeable() {
        return (int)1L;
    }
    public static int WriteCacheChangeable() {
        return (int)2L;
    }
    public static int WriteThroughUnknown() {
        return (int)0L;
    }
    public static int WriteThroughNotSupported() {
        return (int)1L;
    }
    public static int WriteThroughSupported() {
        return (int)2L;
    }
    public static OfAddress PSTORAGE_WRITE_CACHE_PROPERTY = Constants$root.C_POINTER$LAYOUT;
    public static OfAddress PPERSISTENT_RESERVE_COMMAND = Constants$root.C_POINTER$LAYOUT;
    public static int TCCollectionBugCheck() {
        return (int)1L;
    }
    public static int TCCollectionApplicationRequested() {
        return (int)2L;
    }
}


